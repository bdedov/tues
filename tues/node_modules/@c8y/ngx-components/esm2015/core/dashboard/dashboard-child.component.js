import * as tslib_1 from "tslib";
import { Component, forwardRef, HostBinding, Inject, Input, ContentChildren, Output, EventEmitter, ElementRef } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { DashboardComponent } from './dashboard.component';
import { DashboardChildChange } from './dashboard-child-change';
import { DashboardChildActionComponent } from './dashboard-child-action.component';
/**
 * A dashboard child allows to position elements
 * correctly on a grid. The user can then resize and
 * rearrange the elements, as long as they are not `frozen`.
 *
 * By setting `c8y-dashboard-child-actions` and
 * `c8y-dashboard-child-title` on the element you can add
 * custom actions or a custom title to the current child.
 *
 * By adding the correct branded classes, you can define
 * the look and feel of the child. By default it is displayed
 * as a card.
 *
 * Example:
 *
 * ```html
 *   <c8y-dashboard-child
 *     #cpWidget3
 *     [isFrozen]="isFrozen"
 *     [x]="0"
 *     [y]="3"
 *     [width]="4"
 *     [height]="4"
 *     [class]="'card-dashboard panel-content-transparent'"
 *   >
 *     <c8y-dashboard-child-title *ngIf="showTitle">
 *       <span>Transparent!</span>
 *     </c8y-dashboard-child-title>
 *     <c8y-dashboard-child-action>
 *       <a href="" (click)="showTitle = !showTitle; (false)">
 *         <i [c8yIcon]="'heading'"></i> Hide/show title
 *       </a>
 *     </c8y-dashboard-child-action>
 *     <c8y-dashboard-child-action>
 *       <a href="" (click)="cpWidget3.isFrozen = !cpWidget3.isFrozen; (false)">
 *         <i [c8yIcon]="cpWidget3.isFrozen ? 'lock' : 'unlock'"></i> Toggle freeze
 *       </a>
 *     </c8y-dashboard-child-action>
 *     x: {{ cpWidget3.x }}<br />
 *     y: {{ cpWidget3.y }}<br />
 *     width: {{ cpWidget3.width }}<br />
 *     height: {{ cpWidget3.height }}<br />
 *   </c8y-dashboard-child>
 * ```
 */
let DashboardChildComponent = class DashboardChildComponent {
    constructor(dashboard, sanitizer, element) {
        this.dashboard = dashboard;
        this.sanitizer = sanitizer;
        this.element = element;
        this.actions = [];
        this.isResize = false;
        this.isDragging = false;
        this.klasses = {};
        this._pxWidth = '100%';
        this._pxHeight = '100%';
        /**
         * The width of the component in grid-columns.
         */
        this.width = 1;
        /**
         * The height of the component in grid-rows.
         */
        this.height = 1;
        /**
         * The margin of the child in pixel.
         */
        this.margin = 12;
        /**
         * If a dashboard is frozen, all children cannot be moved
         * or resized.
         */
        this.isFrozen = false;
        /**
         * The child content is initialized, as soon it is scrolled into viewport
         */
        this.useIntersection = false;
        /**
         * An event fired if a child change is started (dragging or resizing)
         */
        this.changeStart = new EventEmitter();
        /**
         * An event fired if a child change is ended
         */
        this.changeEnd = new EventEmitter();
        /**
         * All classes added to this child
         */
        this.class = {};
        /**
         * An indicator if the child is intersected (that mean visible for the user)
         */
        this.intersected = false;
    }
    /**
     * Updates the pixel width of the child (used for resizing)
     */
    set pxWidth(value) {
        this._pxWidth = `${value}px`;
    }
    /**
     * Updates the pixel height of the child (used for resizing)
     */
    set pxHeight(value) {
        this._pxHeight = `${value}px`;
    }
    /**
     * nasty workaround for that issue:
     * https://github.com/angular/angular/issues/9343
     */
    get inlineStyle() {
        return this.sanitizer.bypassSecurityTrustStyle(`
    grid-column-start: ${this.x + 1};
    -ms-grid-column: ${this.x + 1};
    grid-row-start: ${this.y + 1};
    -ms-grid-row: ${this.y + 1};
    grid-column-end: span ${this.width};
    -ms-grid-column-span: ${this.width};
    grid-row-end: span ${this.height};
    -ms-grid-row-span: ${this.height};
    display: block;
    margin: ${this.margin || 12}px;
    `);
    }
    ngOnChanges() {
        this.klasses = Object.assign({ card: true, 'card-dashboard': true, disabled: this.isFrozen, 'on-resize': this.isResize }, this.class);
    }
    ngOnInit() {
        if (this.x === undefined || this.y === undefined) {
            setTimeout(() => this.setDynamicDimension());
        }
        if (this.useIntersection && 'IntersectionObserver' in window) {
            const intersectionObserver = new IntersectionObserver(event => (this.intersected = this.childInView(event[0], intersectionObserver)));
            intersectionObserver.observe(this.element.nativeElement);
        }
        else {
            this.intersected = true;
        }
    }
    setDynamicDimension() {
        const ds = new DashboardChildChange(this);
        const { x, y } = ds.findFreeDimension();
        this.x = x;
        this.y = y;
    }
    resizeStarted($event) {
        this.isResize = true;
        this.dashboard.updateRectSize();
        this.dragSource = $event.source;
        const positioning = new DashboardChildChange(this);
        this.changeSubscription = positioning.resize$.subscribe();
        this.changeStart.emit(this);
        this.ngOnChanges();
    }
    dragStarted($event) {
        this.isDragging = true;
        this.dashboard.updateRectSize();
        this.dragSource = $event.source;
        const positioning = new DashboardChildChange(this);
        this.changeSubscription = positioning.drag$.subscribe();
        this.changeStart.emit(this);
    }
    reset($event) {
        this.isResize = false;
        this.isDragging = false;
        this._pxWidth = '100%';
        this._pxHeight = '100%';
        this.ngOnChanges();
        if ($event) {
            $event.source.reset();
        }
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
            this.dashboard.emitChange(this);
            this.changeEnd.emit(this);
        }
    }
    childInView(event, observer) {
        if (event.isIntersecting) {
            observer.unobserve(event.target);
            return true;
        }
        return false;
    }
};
DashboardChildComponent.ctorParameters = () => [
    { type: DashboardComponent, decorators: [{ type: Inject, args: [forwardRef(() => DashboardComponent),] }] },
    { type: DomSanitizer },
    { type: ElementRef }
];
tslib_1.__decorate([
    ContentChildren(DashboardChildActionComponent)
], DashboardChildComponent.prototype, "actions", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "x", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "y", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "width", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "height", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "data", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "margin", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "isFrozen", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "useIntersection", void 0);
tslib_1.__decorate([
    Output()
], DashboardChildComponent.prototype, "changeStart", void 0);
tslib_1.__decorate([
    Output()
], DashboardChildComponent.prototype, "changeEnd", void 0);
tslib_1.__decorate([
    Input()
], DashboardChildComponent.prototype, "class", void 0);
tslib_1.__decorate([
    HostBinding('attr.style')
], DashboardChildComponent.prototype, "inlineStyle", null);
DashboardChildComponent = tslib_1.__decorate([
    Component({
        selector: 'c8y-dashboard-child',
        template: "<div cdkDropList>\n  <div *ngIf=\"isResize\" class=\"card-placeholder\"></div>\n  <div\n    [ngClass]=\"klasses\"\n    cdkDrag\n    [ngStyle]=\"{ width: _pxWidth, height: _pxHeight }\"\n    (cdkDragStarted)=\"dragStarted($event)\"\n    (cdkDragEnded)=\"reset($event)\"\n    [cdkDragDisabled]=\"isFrozen\"\n  >\n    <div\n      class=\"card-header-actions card-header-grid\"\n      [ngClass]=\"{ 'drag-handle': !isFrozen, draggableCursor: !isFrozen }\"\n      cdkDragHandle\n    >\n      <ng-content select=\"c8y-dashboard-child-title\"></ng-content>\n      <div class=\"header-actions\" *ngIf=\"!isFrozen && actions.length > 0\">\n        <div class=\"optionsBtn dropdown\" dropdown container=\"body\">\n          <a\n            title=\"{{ 'Settings' | translate }}\"\n            href=\"\"\n            class=\"btnIcon c8y-dropdown\"\n            (click)=\"(false)\"\n            dropdownToggle\n          >\n            <i [c8yIcon]=\"'cog'\"></i>\n          </a>\n          <ul\n            class=\"dropdown-menu dropdown-menu-right\"\n            style=\"right: -41px;top: 3px;\"\n            *dropdownMenu\n          >\n            <ng-container *ngFor=\"let action of actions\">\n              <ng-container *ngTemplateOutlet=\"action.template\"></ng-container>\n            </ng-container>\n          </ul>\n        </div>\n      </div>\n    </div>\n    <div class=\"card-inner-scroll\">\n      <ng-content></ng-content>\n    </div>\n    <div\n      *ngIf=\"!isFrozen && !isDragging\"\n      class=\"resize-handle\"\n      cdkDrag\n      [cdkDragDisabled]=\"isFrozen\"\n      (cdkDragStarted)=\"resizeStarted($event)\"\n      (cdkDragEnded)=\"reset($event)\"\n    ></div>\n    <div class=\"resize-icon\" *ngIf=\"!isFrozen && !isDragging\"></div>\n\n    <div *cdkDragPlaceholder class=\"card-placeholder\"></div>\n  </div>\n</div>\n",
        host: {
            class: 'dashboard-grid-child'
        }
    }),
    tslib_1.__param(0, Inject(forwardRef(() => DashboardComponent)))
], DashboardChildComponent);
export { DashboardChildComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLWNoaWxkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjOHkvbmd4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb3JlL2Rhc2hib2FyZC9kYXNoYm9hcmQtY2hpbGQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixXQUFXLEVBQ1gsTUFBTSxFQUNOLEtBQUssRUFDTCxlQUFlLEVBQ2YsTUFBTSxFQUNOLFlBQVksRUFDWixVQUFVLEVBQ1gsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXpELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRTNELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBRW5GOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRDRztBQVFILElBQWEsdUJBQXVCLEdBQXBDLE1BQWEsdUJBQXVCO0lBZ0hsQyxZQUN1RCxTQUE2QixFQUMxRSxTQUF1QixFQUN2QixPQUFtQjtRQUYwQixjQUFTLEdBQVQsU0FBUyxDQUFvQjtRQUMxRSxjQUFTLEdBQVQsU0FBUyxDQUFjO1FBQ3ZCLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFsSG1CLFlBQU8sR0FBRyxFQUFFLENBQUM7UUFFN0QsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixlQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ25CLFlBQU8sR0FBRyxFQUFFLENBQUM7UUFFYixhQUFRLEdBQUcsTUFBTSxDQUFDO1FBQ2xCLGNBQVMsR0FBRyxNQUFNLENBQUM7UUFZbkI7O1dBRUc7UUFDTSxVQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRW5COztXQUVHO1FBQ00sV0FBTSxH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LENBQUM7SUFrSEcsbUJBQUEsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUE7R0FqSHBDLHVCQUF1QixDQStMbkM7U0EvTFksdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrRHJhZywgQ2RrRHJhZ0VuZCwgQ2RrRHJhZ1N0YXJ0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2RyYWctZHJvcCc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIGZvcndhcmRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBFbGVtZW50UmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhc2hib2FyZENvbXBvbmVudCB9IGZyb20gJy4vZGFzaGJvYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRDaGlsZERpbWVuc2lvbiwgV2lkZ2V0IH0gZnJvbSAnLi9kYXNoYm9hcmQubW9kZWwnO1xuaW1wb3J0IHsgRGFzaGJvYXJkQ2hpbGRDaGFuZ2UgfSBmcm9tICcuL2Rhc2hib2FyZC1jaGlsZC1jaGFuZ2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkQ2hpbGRBY3Rpb25Db21wb25lbnQgfSBmcm9tICcuL2Rhc2hib2FyZC1jaGlsZC1hY3Rpb24uY29tcG9uZW50JztcblxuLyoqXG4gKiBBIGRhc2hib2FyZCBjaGlsZCBhbGxvd3MgdG8gcG9zaXRpb24gZWxlbWVudHNcbiAqIGNvcnJlY3RseSBvbiBhIGdyaWQuIFRoZSB1c2VyIGNhbiB0aGVuIHJlc2l6ZSBhbmRcbiAqIHJlYXJyYW5nZSB0aGUgZWxlbWVudHMsIGFzIGxvbmcgYXMgdGhleSBhcmUgbm90IGBmcm96ZW5gLlxuICpcbiAqIEJ5IHNldHRpbmcgYGM4eS1kYXNoYm9hcmQtY2hpbGQtYWN0aW9uc2AgYW5kXG4gKiBgYzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZWAgb24gdGhlIGVsZW1lbnQgeW91IGNhbiBhZGRcbiAqIGN1c3RvbSBhY3Rpb25zIG9yIGEgY3VzdG9tIHRpdGxlIHRvIHRoZSBjdXJyZW50IGNoaWxkLlxuICpcbiAqIEJ5IGFkZGluZyB0aGUgY29ycmVjdCBicmFuZGVkIGNsYXNzZXMsIHlvdSBjYW4gZGVmaW5lXG4gKiB0aGUgbG9vayBhbmQgZmVlbCBvZiB0aGUgY2hpbGQuIEJ5IGRlZmF1bHQgaXQgaXMgZGlzcGxheWVkXG4gKiBhcyBhIGNhcmQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiAgIDxjOHktZGFzaGJvYXJkLWNoaWxkXG4gKiAgICAgI2NwV2lkZ2V0M1xuICogICAgIFtpc0Zyb3plbl09XCJpc0Zyb3plblwiXG4gKiAgICAgW3hdPVwiMFwiXG4gKiAgICAgW3ldPVwiM1wiXG4gKiAgICAgW3dpZHRoXT1cIjRcIlxuICogICAgIFtoZWlnaHRdPVwiNFwiXG4gKiAgICAgW2NsYXNzXT1cIidjYXJkLWRhc2hib2FyZCBwYW5lbC1jb250ZW50LXRyYW5zcGFyZW50J1wiXG4gKiAgID5cbiAqICAgICA8Yzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZSAqbmdJZj1cInNob3dUaXRsZVwiPlxuICogICAgICAgPHNwYW4+VHJhbnNwYXJlbnQhPC9zcGFuPlxuICogICAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZC10aXRsZT5cbiAqICAgICA8Yzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4gKiAgICAgICA8YSBocmVmPVwiXCIgKGNsaWNrKT1cInNob3dUaXRsZSA9ICFzaG93VGl0bGU7IChmYWxzZSlcIj5cbiAqICAgICAgICAgPGkgW2M4eUljb25dPVwiJ2hlYWRpbmcnXCI+PC9pPiBIaWRlL3Nob3cgdGl0bGVcbiAqICAgICAgIDwvYT5cbiAqICAgICA8L2M4eS1kYXNoYm9hcmQtY2hpbGQtYWN0aW9uPlxuICogICAgIDxjOHktZGFzaGJvYXJkLWNoaWxkLWFjdGlvbj5cbiAqICAgICAgIDxhIGhyZWY9XCJcIiAoY2xpY2spPVwiY3BXaWRnZXQzLmlzRnJvemVuID0gIWNwV2lkZ2V0My5pc0Zyb3plbjsgKGZhbHNlKVwiPlxuICogICAgICAgICA8aSBbYzh5SWNvbl09XCJjcFdpZGdldDMuaXNGcm96ZW4gPyAnbG9jaycgOiAndW5sb2NrJ1wiPjwvaT4gVG9nZ2xlIGZyZWV6ZVxuICogICAgICAgPC9hPlxuICogICAgIDwvYzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4gKiAgICAgeDoge3sgY3BXaWRnZXQzLnggfX08YnIgLz5cbiAqICAgICB5OiB7eyBjcFdpZGdldDMueSB9fTxiciAvPlxuICogICAgIHdpZHRoOiB7eyBjcFdpZGdldDMud2lkdGggfX08YnIgLz5cbiAqICAgICBoZWlnaHQ6IHt7IGNwV2lkZ2V0My5oZWlnaHQgfX08YnIgLz5cbiAqICAgPC9jOHktZGFzaGJvYXJkLWNoaWxkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1kYXNoYm9hcmQtY2hpbGQnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGFzaGJvYXJkLWNoaWxkLmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnZGFzaGJvYXJkLWdyaWQtY2hpbGQnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ2hpbGRDb21wb25lbnQgaW1wbGVtZW50cyBEYXNoYm9hcmRDaGlsZERpbWVuc2lvbiB7XG4gIEBDb250ZW50Q2hpbGRyZW4oRGFzaGJvYXJkQ2hpbGRBY3Rpb25Db21wb25lbnQpIGFjdGlvbnMgPSBbXTtcbiAgZHJhZ1NvdXJjZTogQ2RrRHJhZztcbiAgaXNSZXNpemUgPSBmYWxzZTtcbiAgaXNEcmFnZ2luZyA9IGZhbHNlO1xuICBrbGFzc2VzID0ge307XG5cbiAgX3B4V2lkdGggPSAnMTAwJSc7XG4gIF9weEhlaWdodCA9ICcxMDAlJztcblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIGNoaWxkLlxuICAgKi9cbiAgQElucHV0KCkgeDtcblxuICAvKipcbiAgICogVGhlIHkgcG9zaXRpb24gb2YgdGhlIGNoaWxkLlxuICAgKi9cbiAgQElucHV0KCkgeTtcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb21wb25lbnQgaW4gZ3JpZC1jb2x1bW5zLlxuICAgKi9cbiAgQElucHV0KCkgd2lkdGggPSAxO1xuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQgaW4gZ3JpZC1yb3dzLlxuICAgKi9cbiAgQElucHV0KCkgaGVpZ2h0ID0gMTtcblxuICAvKipcbiAgICogVGhlIGRhdGEgb2JqZWN0IGNhbiBiZSB1c2VkIGFzIGEgZGF0YVRyYW5zZmVyIG9iamVjdCBmb3IgZXZlbnRzIG9mIHRoZSBjaGlsZC5cbiAgICovXG4gIEBJbnB1dCgpIGRhdGE6IFdpZGdldCB8IGFueTtcblxuICAvKipcbiAgICogVGhlIG1hcmdpbiBvZiB0aGUgY2hpbGQgaW4gcGl4ZWwuXG4gICAqL1xuICBASW5wdXQoKSBtYXJnaW4gPSAxMjtcblxuICAvKipcbiAgICogSWYgYSBkYXNoYm9hcmQgaXMgZnJvemVuLCBhbGwgY2hpbGRyZW4gY2Fubm90IGJlIG1vdmVkXG4gICAqIG9yIHJlc2l6ZWQuXG4gICAqL1xuICBASW5wdXQoKSBpc0Zyb3plbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2hpbGQgY29udGVudCBpcyBpbml0aWFsaXplZCwgYXMgc29vbiBpdCBpcyBzY3JvbGxlZCBpbnRvIHZpZXdwb3J0XG4gICAqL1xuICBASW5wdXQoKSB1c2VJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogQW4gZXZlbnQgZmlyZWQgaWYgYSBjaGlsZCBjaGFuZ2UgaXMgc3RhcnRlZCAoZHJhZ2dpbmcgb3IgcmVzaXppbmcpXG4gICAqL1xuICBAT3V0cHV0KCkgY2hhbmdlU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPERhc2hib2FyZENoaWxkQ29tcG9uZW50PigpO1xuXG4gIC8qKlxuICAgKiBBbiBldmVudCBmaXJlZCBpZiBhIGNoaWxkIGNoYW5nZSBpcyBlbmRlZFxuICAgKi9cbiAgQE91dHB1dCgpIGNoYW5nZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8RGFzaGJvYXJkQ2hpbGRDb21wb25lbnQ+KCk7XG5cbiAgLyoqXG4gICAqIEFsbCBjbGFzc2VzIGFkZGVkIHRvIHRoaXMgY2hpbGRcbiAgICovXG4gIEBJbnB1dCgpXG4gIGNsYXNzOiBzdHJpbmdbXSB8IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBjaGlsZCAodXNlZCBmb3IgcmVzaXppbmcpXG4gICAqL1xuICBzZXQgcHhXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3B4V2lkdGggPSBgJHt2YWx1ZX1weGA7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGl4ZWwgaGVpZ2h0IG9mIHRoZSBjaGlsZCAodXNlZCBmb3IgcmVzaXppbmcpXG4gICAqL1xuICBzZXQgcHhIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9weEhlaWdodCA9IGAke3ZhbHVlfXB4YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbmRpY2F0b3IgaWYgdGhlIGNoaWxkIGlzIGludGVyc2VjdGVkICh0aGF0IG1lYW4gdmlzaWJsZSBmb3IgdGhlIHVzZXIpXG4gICAqL1xuICBpbnRlcnNlY3RlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBuYXN0eSB3b3JrYXJvdW5kIGZvciB0aGF0IGlzc3VlOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy85MzQzXG4gICAqL1xuICBASG9zdEJpbmRpbmcoJ2F0dHIuc3R5bGUnKVxuICBnZXQgaW5saW5lU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShgXG4gICAgZ3JpZC1jb2x1bW4tc3RhcnQ6ICR7dGhpcy54ICsgMX07XG4gICAgLW1zLWdyaWQtY29sdW1uOiAke3RoaXMueCArIDF9O1xuICAgIGdyaWQtcm93LXN0YXJ0OiAke3RoaXMueSArIDF9O1xuICAgIC1tcy1ncmlkLXJvdzogJHt0aGlzLnkgKyAxfTtcbiAgICBncmlkLWNvbHVtbi1lbmQ6IHNwYW4gJHt0aGlzLndpZHRofTtcbiAgICAtbXMtZ3JpZC1jb2x1bW4tc3BhbjogJHt0aGlzLndpZHRofTtcbiAgICBncmlkLXJvdy1lbmQ6IHNwYW4gJHt0aGlzLmhlaWdodH07XG4gICAgLW1zLWdyaWQtcm93LXNwYW46ICR7dGhpcy5oZWlnaHR9O1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbjogJHt0aGlzLm1hcmdpbiB8fCAxMn1weDtcbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gd2hpY2ggaXMgbGlzdGVuIHRvXG4gICAqIG9uIGNoYW5nZXMgKGRyYWcgb3IgcmVzaXplKS5cbiAgICovXG4gIGNoYW5nZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXNoYm9hcmRDb21wb25lbnQpKSBwdWJsaWMgZGFzaGJvYXJkOiBEYXNoYm9hcmRDb21wb25lbnQsXG4gICAgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWZcbiAgKSB7fVxuXG4gIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIHRoaXMua2xhc3NlcyA9IHtcbiAgICAgIGNhcmQ6IHRydWUsXG4gICAgICAnY2FyZC1kYXNoYm9hcmQnOiB0cnVlLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuaXNGcm96ZW4sXG4gICAgICAnb24tcmVzaXplJzogdGhpcy5pc1Jlc2l6ZSxcbiAgICAgIC4uLnRoaXMuY2xhc3NcbiAgICB9O1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMueCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0RHluYW1pY0RpbWVuc2lvbigpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlSW50ZXJzZWN0aW9uICYmICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgZXZlbnQgPT4gKHRoaXMuaW50ZXJzZWN0ZWQgPSB0aGlzLmNoaWxkSW5WaWV3KGV2ZW50WzBdLCBpbnRlcnNlY3Rpb25PYnNlcnZlcikpXG4gICAgICApO1xuICAgICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJzZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldER5bmFtaWNEaW1lbnNpb24oKSB7XG4gICAgY29uc3QgZHMgPSBuZXcgRGFzaGJvYXJkQ2hpbGRDaGFuZ2UodGhpcyk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBkcy5maW5kRnJlZURpbWVuc2lvbigpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIHJlc2l6ZVN0YXJ0ZWQoJGV2ZW50OiBDZGtEcmFnU3RhcnQpIHtcbiAgICB0aGlzLmlzUmVzaXplID0gdHJ1ZTtcbiAgICB0aGlzLmRhc2hib2FyZC51cGRhdGVSZWN0U2l6ZSgpO1xuICAgIHRoaXMuZHJhZ1NvdXJjZSA9ICRldmVudC5zb3VyY2U7XG4gICAgY29uc3QgcG9zaXRpb25pbmcgPSBuZXcgRGFzaGJvYXJkQ2hpbGRDaGFuZ2UodGhpcyk7XG4gICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24gPSBwb3NpdGlvbmluZy5yZXNpemUkLnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2hhbmdlU3RhcnQuZW1pdCh0aGlzKTtcbiAgICB0aGlzLm5nT25DaGFuZ2VzKCk7XG4gIH1cblxuICBkcmFnU3RhcnRlZCgkZXZlbnQ6IENka0RyYWdTdGFydCkge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy5kYXNoYm9hcmQudXBkYXRlUmVjdFNpemUoKTtcbiAgICB0aGlzLmRyYWdTb3VyY2UgPSAkZXZlbnQuc291cmNlO1xuICAgIGNvbnN0IHBvc2l0aW9uaW5nID0gbmV3IERhc2hib2FyZENoaWxkQ2hhbmdlKHRoaXMpO1xuICAgIHRoaXMuY2hhbmdlU3Vic2NyaXB0aW9uID0gcG9zaXRpb25pbmcuZHJhZyQuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jaGFuZ2VTdGFydC5lbWl0KHRoaXMpO1xuICB9XG5cbiAgcmVzZXQoJGV2ZW50PzogQ2RrRHJhZ0VuZCkge1xuICAgIHRoaXMuaXNSZXNpemUgPSBmYWxzZTtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9weFdpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuX3B4SGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMubmdPbkNoYW5nZXMoKTtcbiAgICBpZiAoJGV2ZW50KSB7XG4gICAgICAkZXZlbnQuc291cmNlLnJlc2V0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkLmVtaXRDaGFuZ2UodGhpcyk7XG4gICAgICB0aGlzLmNoYW5nZUVuZC5lbWl0KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hpbGRJblZpZXcoZXZlbnQsIG9ic2VydmVyKSB7XG4gICAgaWYgKGV2ZW50LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZXZlbnQudGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==