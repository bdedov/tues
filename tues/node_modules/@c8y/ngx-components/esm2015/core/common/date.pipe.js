import * as tslib_1 from "tslib";
import { DatePipe as NgDatePipe } from '@angular/common';
import { Inject, LOCALE_ID, Pipe } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { gettext } from '../i18n/gettext';
/**
 * The range of times supported by ECMAScript Date objects in milliseconds.
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1
 */
export const ES_MAX_TIME_MILLISECONDS = 8640000000000000;
/**
 * Formats a date value according to locale rules. If no other format specified it defaults to `medium`
 * used as standard date/time format.
 *
 * Extends Angular's DatePipe in a way so that date values exceeding the range supported by ECMAScript
 * are displayed as earliest/latest supported point in time printed in the desired format pre- or postfixed
 * by the word `before` or `after`, respectively.
 * In all other cases the pipe behaves as the standard [DatePipe]{@link https://angular.io/api/common/DatePipe}.
 *
 * ```html
 * <span class="highlight">{{ deadline | c8yDate }}</span> <!-- e.g. 7 May 2020, 17:45:19 (en-GB) or 07.05.2020, 17:45:19 (de) -->
 * <span>{{ lastUpdated | c8yDate: 'a h:MM:ss' }}</span> <!-- e.g. pm 5:45:19 -->
 * <span>{{ 8640000000000000 + 1 | c8yDate }}</span> <!-- e.g. after 13 Sep 275760, 03:00:00 --> ```
 */
let DatePipe = class DatePipe extends NgDatePipe {
    constructor(locale, translateService) {
        super(locale);
        this.translateService = translateService;
    }
    transform(value, format = 'medium', timezone, locale) {
        let valueInBounds = value;
        let valueBefore = false;
        let valueBeyond = false;
        if (typeof value === 'number' && !isNaN(value)) {
            valueInBounds = Math.min(value, ES_MAX_TIME_MILLISECONDS);
            valueInBounds = Math.max(valueInBounds, -ES_MAX_TIME_MILLISECONDS);
            valueBefore = value < -ES_MAX_TIME_MILLISECONDS;
            valueBeyond = value > ES_MAX_TIME_MILLISECONDS;
        }
        let result = super.transform(valueInBounds, format, timezone, locale);
        if (valueBefore) {
            result = this.translateService.instant(gettext(`before {{date}}`), { date: result });
        }
        else if (valueBeyond) {
            result = this.translateService.instant(gettext(`after {{date}}`), { date: result });
        }
        return result;
    }
};
DatePipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: TranslateService }
];
DatePipe = tslib_1.__decorate([
    Pipe({ name: 'c8yDate' }),
    tslib_1.__param(0, Inject(LOCALE_ID))
], DatePipe);
export { DatePipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGM4eS9uZ3gtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImNvcmUvY29tbW9uL2RhdGUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFFBQVEsSUFBSSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTFDOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLHdCQUF3QixHQUFXLGdCQUFnQixDQUFDO0FBRWpFOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSCxJQUFhLFFBQVEsR0FBckIsTUFBYSxRQUFTLFNBQVEsVUFBVTtJQUN0QyxZQUErQixNQUFjLEVBQVUsZ0JBQWtDO1FBQ3ZGLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUR1QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBRXpGLENBQUM7SUFFRCxTQUFTLENBQ1AsS0FBVSxFQUNWLFNBQWlCLFFBQVEsRUFDekIsUUFBaUIsRUFDakIsTUFBZTtRQUVmLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQztRQUMxQixJQUFJLFdBQVcsR0FBWSxLQUFLLENBQUM7UUFDakMsSUFBSSxXQUFXLEdBQVksS0FBSyxDQUFDO1FBRWpDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzlDLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1lBQzFELGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDLHdCQUF3QixDQUFDLENBQUM7WUFFbkUsV0FBVyxHQUFHLEtBQUssR0FBRyxDQUFDLHdCQUF3QixDQUFDO1lBQ2hELFdBQVcsR0FBRyxLQUFLLEdBQUcsd0JBQXdCLENBQUM7U0FDaEQ7UUFDRCxJQUFJLE1BQU0sR0FBVyxLQUFLLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTlFLElBQUksV0FBVyxFQUFFO1lBQ2YsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUN0RjthQUFNLElBQUksV0FBVyxFQUFFO1lBQ3RCLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDckY7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0YsQ0FBQTs7eUNBL0JjLE1BQU0sU0FBQyxTQUFTO1lBQTRDLGdCQUFnQjs7QUFEOUUsUUFBUTtJQURwQixJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFFWCxtQkFBQSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7R0FEbkIsUUFBUSxDQWdDcEI7U0FoQ1ksUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVQaXBlIGFzIE5nRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBMT0NBTEVfSUQsIFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGdldHRleHQgfSBmcm9tICcuLi9pMThuL2dldHRleHQnO1xuXG4vKipcbiAqIFRoZSByYW5nZSBvZiB0aW1lcyBzdXBwb3J0ZWQgYnkgRUNNQVNjcmlwdCBEYXRlIG9iamVjdHMgaW4gbWlsbGlzZWNvbmRzLlxuICogQHNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuOS4xLjFcbiAqL1xuZXhwb3J0IGNvbnN0IEVTX01BWF9USU1FX01JTExJU0VDT05EUzogbnVtYmVyID0gODY0MDAwMDAwMDAwMDAwMDtcblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSB2YWx1ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLiBJZiBubyBvdGhlciBmb3JtYXQgc3BlY2lmaWVkIGl0IGRlZmF1bHRzIHRvIGBtZWRpdW1gXG4gKiB1c2VkIGFzIHN0YW5kYXJkIGRhdGUvdGltZSBmb3JtYXQuXG4gKlxuICogRXh0ZW5kcyBBbmd1bGFyJ3MgRGF0ZVBpcGUgaW4gYSB3YXkgc28gdGhhdCBkYXRlIHZhbHVlcyBleGNlZWRpbmcgdGhlIHJhbmdlIHN1cHBvcnRlZCBieSBFQ01BU2NyaXB0XG4gKiBhcmUgZGlzcGxheWVkIGFzIGVhcmxpZXN0L2xhdGVzdCBzdXBwb3J0ZWQgcG9pbnQgaW4gdGltZSBwcmludGVkIGluIHRoZSBkZXNpcmVkIGZvcm1hdCBwcmUtIG9yIHBvc3RmaXhlZFxuICogYnkgdGhlIHdvcmQgYGJlZm9yZWAgb3IgYGFmdGVyYCwgcmVzcGVjdGl2ZWx5LlxuICogSW4gYWxsIG90aGVyIGNhc2VzIHRoZSBwaXBlIGJlaGF2ZXMgYXMgdGhlIHN0YW5kYXJkIFtEYXRlUGlwZV17QGxpbmsgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGF0ZVBpcGV9LlxuICpcbiAqIGBgYGh0bWxcbiAqIDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+e3sgZGVhZGxpbmUgfCBjOHlEYXRlIH19PC9zcGFuPiA8IS0tIGUuZy4gNyBNYXkgMjAyMCwgMTc6NDU6MTkgKGVuLUdCKSBvciAwNy4wNS4yMDIwLCAxNzo0NToxOSAoZGUpIC0tPlxuICogPHNwYW4+e3sgbGFzdFVwZGF0ZWQgfCBjOHlEYXRlOiAnYSBoOk1NOnNzJyB9fTwvc3Bhbj4gPCEtLSBlLmcuIHBtIDU6NDU6MTkgLS0+XG4gKiA8c3Bhbj57eyA4NjQwMDAwMDAwMDAwMDAwICsgMSB8IGM4eURhdGUgfX08L3NwYW4+IDwhLS0gZS5nLiBhZnRlciAxMyBTZXAgMjc1NzYwLCAwMzowMDowMCAtLT4gYGBgXG4gKi9cbkBQaXBlKHsgbmFtZTogJ2M4eURhdGUnIH0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpcGUgZXh0ZW5kcyBOZ0RhdGVQaXBlIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChMT0NBTEVfSUQpIGxvY2FsZTogc3RyaW5nLCBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UpIHtcbiAgICBzdXBlcihsb2NhbGUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKFxuICAgIHZhbHVlOiBhbnksXG4gICAgZm9ybWF0OiBzdHJpbmcgPSAnbWVkaXVtJyxcbiAgICB0aW1lem9uZT86IHN0cmluZyxcbiAgICBsb2NhbGU/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgbGV0IHZhbHVlSW5Cb3VuZHMgPSB2YWx1ZTtcbiAgICBsZXQgdmFsdWVCZWZvcmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBsZXQgdmFsdWVCZXlvbmQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlSW5Cb3VuZHMgPSBNYXRoLm1pbih2YWx1ZSwgRVNfTUFYX1RJTUVfTUlMTElTRUNPTkRTKTtcbiAgICAgIHZhbHVlSW5Cb3VuZHMgPSBNYXRoLm1heCh2YWx1ZUluQm91bmRzLCAtRVNfTUFYX1RJTUVfTUlMTElTRUNPTkRTKTtcblxuICAgICAgdmFsdWVCZWZvcmUgPSB2YWx1ZSA8IC1FU19NQVhfVElNRV9NSUxMSVNFQ09ORFM7XG4gICAgICB2YWx1ZUJleW9uZCA9IHZhbHVlID4gRVNfTUFYX1RJTUVfTUlMTElTRUNPTkRTO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBzdXBlci50cmFuc2Zvcm0odmFsdWVJbkJvdW5kcywgZm9ybWF0LCB0aW1lem9uZSwgbG9jYWxlKTtcblxuICAgIGlmICh2YWx1ZUJlZm9yZSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoZ2V0dGV4dChgYmVmb3JlIHt7ZGF0ZX19YCksIHsgZGF0ZTogcmVzdWx0IH0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWVCZXlvbmQpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNsYXRlU2VydmljZS5pbnN0YW50KGdldHRleHQoYGFmdGVyIHt7ZGF0ZX19YCksIHsgZGF0ZTogcmVzdWx0IH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdfQ==