import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
export const HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
let NavigatorService = class NavigatorService extends StateService {
    constructor(injector, router) {
        super();
        this.injector = injector;
        this.router = router;
        this.refreshTrigger = new Subject();
        this.state$ = new BehaviorSubject(new Set());
        this.firstUrl = true;
        const rootNode = new NavigatorNodeRoot();
        this.items$ = fromTrigger(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_NAVIGATOR_NODES, []),
            stateToFactory(this.state$),
        ]).pipe(map((nodes) => {
            const noParent = nodes.filter(node => !node.parent);
            const withParent = nodes.filter(node => node.parent);
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            const sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach((node) => rootNode.addRoot(node));
            return rootNode.children;
        }), shareReplay(1));
    }
    openOnFirstUrl(node) {
        if (this.firstUrl && !!node.path) {
            return this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url);
        }
        return false;
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Refresh the extension factories
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Adds a new node to the navigator.
     * @param nav The node to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes a node from the navigator.
     * @param nav The node ro remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
};
NavigatorService.ctorParameters = () => [
    { type: Injector },
    { type: Router }
];
NavigatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
NavigatorService = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    })
], NavigatorService);
export { NavigatorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9uYXZpZ2F0b3IvbmF2aWdhdG9yLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQWtCLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBR2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFFMUQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBRWhGOztHQUVHO0FBSUgsSUFBYSxnQkFBZ0IsR0FBN0IsTUFBYSxnQkFBaUIsU0FBUSxZQUFZO0lBTWhELFlBQ1UsUUFBa0IsRUFDbEIsTUFBYztRQUV0QixLQUFLLEVBQUUsQ0FBQztRQUhBLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQU5mLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUMvQixXQUFNLEdBQUcsSUFBSSxlQUFlLENBQXFCLElBQUksR0FBRyxFQUFpQixDQUFDLENBQUM7UUFDcEYsYUFBUSxHQUFHLElBQUksQ0FBQztRQU9kLE1BQU0sUUFBUSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNyRCxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLENBQUM7WUFDakQsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDNUIsQ0FBQyxDQUFDLElBQUksQ0FDTCxHQUFHLENBQUMsQ0FBQyxLQUFtQyxFQUFFLEVBQUU7WUFDMUMsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BELE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFckQsc0VBQXNFO1lBQ3RFLHdFQUF3RTtZQUN4RSx3RkFBd0Y7WUFDeEYsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNoRixRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDakIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUMzQixDQUFDLENBQUMsRUFDRixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFRCxjQUFjLENBQUMsSUFBbUI7UUFDaEMsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ25HO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTztRQUNMLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHLENBQUMsSUFBbUI7UUFDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsSUFBbUI7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7Q0FDRixDQUFBOztZQWpFcUIsUUFBUTtZQUNWLE1BQU07OztBQVJiLGdCQUFnQjtJQUg1QixVQUFVLENBQUM7UUFDVixVQUFVLEVBQUUsTUFBTTtLQUNuQixDQUFDO0dBQ1csZ0JBQWdCLENBd0U1QjtTQXhFWSxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBFeHRlbnNpb25Qb2ludCwgZnJvbVRyaWdnZXIsIHNvcnRCeVByaW9yaXR5LCBzdGF0ZVRvRmFjdG9yeSB9IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3N0YXRlLXNlcnZpY2UuYWJzdHJhY3QnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZSB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZURhdGEgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlLWRhdGEnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZVJvb3QgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlLXJvb3QnO1xuXG4vKipcbiAqIEEgaG9vayB0byB1c2UgZm9yIE11bHRpIFByb3ZpZGVyIGV4dGVuc2lvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IEhPT0tfTkFWSUdBVE9SX05PREVTID0gbmV3IEluamVjdGlvblRva2VuKCdOYXZpZ2F0b3JOb2Rlc0ZhY3RvcnknKTtcblxuLyoqXG4gKiBBIHNlcnZpY2Ugd2hpY2ggZGVmaW5lcyB0aGUgbmF2aWdhdG9yLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JTZXJ2aWNlIGV4dGVuZHMgU3RhdGVTZXJ2aWNlIGltcGxlbWVudHMgRXh0ZW5zaW9uUG9pbnQ8TmF2aWdhdG9yTm9kZT4ge1xuICBpdGVtcyQ6IE9ic2VydmFibGU8TmF2aWdhdG9yTm9kZVtdPjtcbiAgcmVhZG9ubHkgcmVmcmVzaFRyaWdnZXIgPSBuZXcgU3ViamVjdCgpO1xuICByZWFkb25seSBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxOYXZpZ2F0b3JOb2RlPj4obmV3IFNldDxOYXZpZ2F0b3JOb2RlPigpKTtcbiAgZmlyc3RVcmwgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXJcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBOYXZpZ2F0b3JOb2RlUm9vdCgpO1xuICAgIHRoaXMuaXRlbXMkID0gZnJvbVRyaWdnZXIocm91dGVyLCB0aGlzLnJlZnJlc2hUcmlnZ2VyLCBbXG4gICAgICAoKSA9PiB0aGlzLmluamVjdG9yLmdldChIT09LX05BVklHQVRPUl9OT0RFUywgW10pLFxuICAgICAgc3RhdGVUb0ZhY3RvcnkodGhpcy5zdGF0ZSQpLFxuICAgIF0pLnBpcGUoXG4gICAgICBtYXAoKG5vZGVzOiBQYXJ0aWFsPE5hdmlnYXRvck5vZGVEYXRhW10+KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vUGFyZW50ID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gIW5vZGUucGFyZW50KTtcbiAgICAgICAgY29uc3Qgd2l0aFBhcmVudCA9IG5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUucGFyZW50KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgc29ydGVkTm9kZXMgYXJyYXksIHRoZSBub2RlcyBhcmUgc2VxdWVudGlhbGx5IGNyZWF0ZWQuXG4gICAgICAgIC8vIE5vZGVzIHNvcnRpbmcgaXMgZG9uZSBpbiB0d28gc3RlcHMgdG8gaGF2ZSB0aGUgdG9wLWxldmVsIG5vZGVzIGZpcnN0LlxuICAgICAgICAvLyBUaGlzIHdheSwgYnkgdGhlIHRpbWUgd2UgYXJlIGFkZGluZyBhIGNoaWxkIG5vZGUsIHRoZSBwYXJlbnQgbm9kZSBpcyBhbHJlYWR5IHByZXNlbnQuXG4gICAgICAgIGNvbnN0IHNvcnRlZE5vZGVzID0gc29ydEJ5UHJpb3JpdHkobm9QYXJlbnQpLmNvbmNhdChzb3J0QnlQcmlvcml0eSh3aXRoUGFyZW50KSk7XG4gICAgICAgIHJvb3ROb2RlLmVtcHR5KCk7XG4gICAgICAgIHNvcnRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHJvb3ROb2RlLmFkZFJvb3Qobm9kZSkpO1xuICAgICAgICByZXR1cm4gcm9vdE5vZGUuY2hpbGRyZW47XG4gICAgICB9KSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcbiAgfVxuXG4gIG9wZW5PbkZpcnN0VXJsKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICBpZiAodGhpcy5maXJzdFVybCAmJiAhIW5vZGUucGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmlzQWN0aXZlKG5vZGUucGF0aCwgbm9kZS5yb3V0ZXJMaW5rRXhhY3QpIHx8IG5vZGUub3Blbk9uU3RhcnQodGhpcy5yb3V0ZXIudXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpOiBTZXQ8TmF2aWdhdG9yTm9kZT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVmcmVzaFRyaWdnZXIubmV4dCgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IG5vZGUgdG8gdGhlIG5hdmlnYXRvci5cbiAgICogQHBhcmFtIG5hdiBUaGUgbm9kZSB0byBhZGQuXG4gICAqL1xuICBhZGQoaXRlbTogTmF2aWdhdG9yTm9kZSkge1xuICAgIHRoaXMuc3RhdGUuYWRkKGl0ZW0pO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0gbmF2IFRoZSBub2RlIHJvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxufVxuIl19