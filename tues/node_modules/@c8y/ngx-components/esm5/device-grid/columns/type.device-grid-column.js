import * as tslib_1 from "tslib";
import { gettext } from '@c8y/ngx-components';
import { BaseDeviceGridColumn } from './base.device-grid-column';
var TypeDeviceGridColumn = /** @class */ (function (_super) {
    tslib_1.__extends(TypeDeviceGridColumn, _super);
    function TypeDeviceGridColumn() {
        var _this = _super.call(this) || this;
        _this.name = 'type';
        _this.path = 'type';
        _this.header = gettext('Type');
        _this.filterable = true;
        _this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    types: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'types',
                    title: gettext('Show devices with type'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'types[]',
                            notitle: true,
                            placeholder: gettext('e.g. MyType, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter: function (model) {
                var filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        _this.sortable = true;
        _this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
        return _this;
    }
    return TypeDeviceGridColumn;
}(BaseDeviceGridColumn));
export { TypeDeviceGridColumn };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5kZXZpY2UtZ3JpZC1jb2x1bW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzL2RldmljZS1ncmlkLyIsInNvdXJjZXMiOlsiY29sdW1ucy90eXBlLmRldmljZS1ncmlkLWNvbHVtbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRWpFO0lBQTBDLGdEQUFvQjtJQUM1RDtRQUFBLFlBQ0UsaUJBQU8sU0E0Q1I7UUExQ0MsS0FBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUM7UUFDbkIsS0FBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUM7UUFDbkIsS0FBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDdkIsS0FBSSxDQUFDLGVBQWUsR0FBRztZQUNyQixNQUFNLEVBQUU7Z0JBQ04sSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsVUFBVSxFQUFFO29CQUNWLEtBQUssRUFBRTt3QkFDTCxJQUFJLEVBQUUsT0FBTzt3QkFDYixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxFQUFFLFFBQVE7eUJBQ2Y7cUJBQ0Y7aUJBQ0Y7YUFDRjtZQUNELElBQUksRUFBRTtnQkFDSjtvQkFDRSxHQUFHLEVBQUUsT0FBTztvQkFDWixLQUFLLEVBQUUsT0FBTyxDQUFDLHdCQUF3QixDQUFDO29CQUN4QyxHQUFHLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQztvQkFDbEIsS0FBSyxFQUFFO3dCQUNMOzRCQUNFLEdBQUcsRUFBRSxTQUFTOzRCQUNkLE9BQU8sRUFBRSxJQUFJOzRCQUNiLFdBQVcsRUFBRSxPQUFPLENBQUMsZ0VBQWdFLENBQUM7eUJBQ3ZGO3FCQUNGO2lCQUNGO2FBQ0Y7WUFDRCxTQUFTLEVBQVQsVUFBVSxLQUFVO2dCQUNsQixJQUFNLE1BQU0sR0FBUSxFQUFFLENBQUM7Z0JBQ3ZCLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7b0JBQ3RCLE1BQU0sQ0FBQyxJQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2lCQUNyQztnQkFDRCxPQUFPLE1BQU0sQ0FBQztZQUNoQixDQUFDO1NBQ0YsQ0FBQztRQUVGLEtBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxrQkFBa0IsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQzs7SUFDbEUsQ0FBQztJQUNILDJCQUFDO0FBQUQsQ0FBQyxBQS9DRCxDQUEwQyxvQkFBb0IsR0ErQzdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGV4dCB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgQmFzZURldmljZUdyaWRDb2x1bW4gfSBmcm9tICcuL2Jhc2UuZGV2aWNlLWdyaWQtY29sdW1uJztcblxuZXhwb3J0IGNsYXNzIFR5cGVEZXZpY2VHcmlkQ29sdW1uIGV4dGVuZHMgQmFzZURldmljZUdyaWRDb2x1bW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5uYW1lID0gJ3R5cGUnO1xuICAgIHRoaXMucGF0aCA9ICd0eXBlJztcbiAgICB0aGlzLmhlYWRlciA9IGdldHRleHQoJ1R5cGUnKTtcblxuICAgIHRoaXMuZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5maWx0ZXJpbmdDb25maWcgPSB7XG4gICAgICBzY2hlbWE6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9ybTogW1xuICAgICAgICB7XG4gICAgICAgICAga2V5OiAndHlwZXMnLFxuICAgICAgICAgIHRpdGxlOiBnZXR0ZXh0KCdTaG93IGRldmljZXMgd2l0aCB0eXBlJyksXG4gICAgICAgICAgYWRkOiBnZXR0ZXh0KCdPcicpLFxuICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogJ3R5cGVzW10nLFxuICAgICAgICAgICAgICBub3RpdGxlOiB0cnVlLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogZ2V0dGV4dCgnZS5nLiBNeVR5cGUsIHlvdSBjYW4gdXNlIGFuIGFzdGVyaXNrICgqKSBhcyB3aWxkY2FyZCBjaGFyYWN0ZXInKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGdldEZpbHRlcihtb2RlbDogYW55KTogYW55IHtcbiAgICAgICAgY29uc3QgZmlsdGVyOiBhbnkgPSB7fTtcbiAgICAgICAgaWYgKG1vZGVsLnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgIGZpbHRlci50eXBlID0geyBfX2luOiBtb2RlbC50eXBlcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc29ydGFibGUgPSB0cnVlO1xuICAgIHRoaXMuc29ydGluZ0NvbmZpZyA9IHsgcGF0aFNvcnRpbmdDb25maWdzOiBbeyBwYXRoOiAndHlwZScgfV0gfTtcbiAgfVxufVxuIl19