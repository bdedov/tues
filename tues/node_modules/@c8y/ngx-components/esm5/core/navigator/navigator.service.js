import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
export var HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
var NavigatorService = /** @class */ (function (_super) {
    tslib_1.__extends(NavigatorService, _super);
    function NavigatorService(injector, router) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        _this.router = router;
        _this.refreshTrigger = new Subject();
        _this.state$ = new BehaviorSubject(new Set());
        _this.firstUrl = true;
        var rootNode = new NavigatorNodeRoot();
        _this.items$ = fromTrigger(router, _this.refreshTrigger, [
            function () { return _this.injector.get(HOOK_NAVIGATOR_NODES, []); },
            stateToFactory(_this.state$),
        ]).pipe(map(function (nodes) {
            var noParent = nodes.filter(function (node) { return !node.parent; });
            var withParent = nodes.filter(function (node) { return node.parent; });
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            var sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(function (node) { return rootNode.addRoot(node); });
            return rootNode.children;
        }), shareReplay(1));
        return _this;
    }
    NavigatorService.prototype.openOnFirstUrl = function (node) {
        if (this.firstUrl && !!node.path) {
            return this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url);
        }
        return false;
    };
    Object.defineProperty(NavigatorService.prototype, "state", {
        /**
         * Returns the current state.
         * @readonly
         * @returns The current set of actions.
         */
        get: function () {
            return this.state$.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Refresh the extension factories
     */
    NavigatorService.prototype.refresh = function () {
        this.refreshTrigger.next(1);
    };
    /**
     * Adds a new node to the navigator.
     * @param nav The node to add.
     */
    NavigatorService.prototype.add = function (item) {
        this.state.add(item);
        this.emitNewState();
    };
    /**
     * Removes a node from the navigator.
     * @param nav The node ro remove.
     */
    NavigatorService.prototype.remove = function (item) {
        this.state.delete(item);
        this.emitNewState();
    };
    NavigatorService.ctorParameters = function () { return [
        { type: Injector },
        { type: Router }
    ]; };
    NavigatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
    NavigatorService = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NavigatorService);
    return NavigatorService;
}(StateService));
export { NavigatorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9uYXZpZ2F0b3IvbmF2aWdhdG9yLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQWtCLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBR2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7QUFFMUQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsSUFBTSxvQkFBb0IsR0FBRyxJQUFJLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBRWhGOztHQUVHO0FBSUg7SUFBc0MsNENBQVk7SUFNaEQsMEJBQ1UsUUFBa0IsRUFDbEIsTUFBYztRQUZ4QixZQUlFLGlCQUFPLFNBb0JSO1FBdkJTLGNBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsWUFBTSxHQUFOLE1BQU0sQ0FBUTtRQU5mLG9CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUMvQixZQUFNLEdBQUcsSUFBSSxlQUFlLENBQXFCLElBQUksR0FBRyxFQUFpQixDQUFDLENBQUM7UUFDcEYsY0FBUSxHQUFHLElBQUksQ0FBQztRQU9kLElBQU0sUUFBUSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUN6QyxLQUFJLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsS0FBSSxDQUFDLGNBQWMsRUFBRTtZQUNyRCxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxDQUFDLEVBQTNDLENBQTJDO1lBQ2pELGNBQWMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDO1NBQzVCLENBQUMsQ0FBQyxJQUFJLENBQ0wsR0FBRyxDQUFDLFVBQUMsS0FBbUM7WUFDdEMsSUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBWixDQUFZLENBQUMsQ0FBQztZQUNwRCxJQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sRUFBWCxDQUFXLENBQUMsQ0FBQztZQUVyRCxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHdGQUF3RjtZQUN4RixJQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hGLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNqQixXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSSxJQUFLLE9BQUEsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUMzQixDQUFDLENBQUMsRUFDRixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2YsQ0FBQzs7SUFDSixDQUFDO0lBRUQseUNBQWMsR0FBZCxVQUFlLElBQW1CO1FBQ2hDLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNoQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNuRztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQU9ELHNCQUFJLG1DQUFLO1FBTFQ7Ozs7V0FJRzthQUNIO1lBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUMzQixDQUFDOzs7T0FBQTtJQUVEOztPQUVHO0lBQ0gsa0NBQU8sR0FBUDtRQUNFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSCw4QkFBRyxHQUFILFVBQUksSUFBbUI7UUFDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxpQ0FBTSxHQUFOLFVBQU8sSUFBbUI7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7O2dCQWhFbUIsUUFBUTtnQkFDVixNQUFNOzs7SUFSYixnQkFBZ0I7UUFINUIsVUFBVSxDQUFDO1lBQ1YsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztPQUNXLGdCQUFnQixDQXdFNUI7MkJBN0ZEO0NBNkZDLEFBeEVELENBQXNDLFlBQVksR0F3RWpEO1NBeEVZLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEV4dGVuc2lvblBvaW50LCBmcm9tVHJpZ2dlciwgc29ydEJ5UHJpb3JpdHksIHN0YXRlVG9GYWN0b3J5IH0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZSc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlRGF0YSB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUtZGF0YSc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlUm9vdCB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUtcm9vdCc7XG5cbi8qKlxuICogQSBob29rIHRvIHVzZSBmb3IgTXVsdGkgUHJvdmlkZXIgZXh0ZW5zaW9uLlxuICovXG5leHBvcnQgY29uc3QgSE9PS19OQVZJR0FUT1JfTk9ERVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05hdmlnYXRvck5vZGVzRmFjdG9yeScpO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSBuYXZpZ2F0b3IuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvclNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxOYXZpZ2F0b3JOb2RlPiB7XG4gIGl0ZW1zJDogT2JzZXJ2YWJsZTxOYXZpZ2F0b3JOb2RlW10+O1xuICByZWFkb25seSByZWZyZXNoVHJpZ2dlciA9IG5ldyBTdWJqZWN0KCk7XG4gIHJlYWRvbmx5IHN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8U2V0PE5hdmlnYXRvck5vZGU+PihuZXcgU2V0PE5hdmlnYXRvck5vZGU+KCkpO1xuICBmaXJzdFVybCA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlclxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gbmV3IE5hdmlnYXRvck5vZGVSb290KCk7XG4gICAgdGhpcy5pdGVtcyQgPSBmcm9tVHJpZ2dlcihyb3V0ZXIsIHRoaXMucmVmcmVzaFRyaWdnZXIsIFtcbiAgICAgICgpID0+IHRoaXMuaW5qZWN0b3IuZ2V0KEhPT0tfTkFWSUdBVE9SX05PREVTLCBbXSksXG4gICAgICBzdGF0ZVRvRmFjdG9yeSh0aGlzLnN0YXRlJCksXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCgobm9kZXM6IFBhcnRpYWw8TmF2aWdhdG9yTm9kZURhdGFbXT4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9QYXJlbnQgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiAhbm9kZS5wYXJlbnQpO1xuICAgICAgICBjb25zdCB3aXRoUGFyZW50ID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5wYXJlbnQpO1xuXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSBzb3J0ZWROb2RlcyBhcnJheSwgdGhlIG5vZGVzIGFyZSBzZXF1ZW50aWFsbHkgY3JlYXRlZC5cbiAgICAgICAgLy8gTm9kZXMgc29ydGluZyBpcyBkb25lIGluIHR3byBzdGVwcyB0byBoYXZlIHRoZSB0b3AtbGV2ZWwgbm9kZXMgZmlyc3QuXG4gICAgICAgIC8vIFRoaXMgd2F5LCBieSB0aGUgdGltZSB3ZSBhcmUgYWRkaW5nIGEgY2hpbGQgbm9kZSwgdGhlIHBhcmVudCBub2RlIGlzIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgY29uc3Qgc29ydGVkTm9kZXMgPSBzb3J0QnlQcmlvcml0eShub1BhcmVudCkuY29uY2F0KHNvcnRCeVByaW9yaXR5KHdpdGhQYXJlbnQpKTtcbiAgICAgICAgcm9vdE5vZGUuZW1wdHkoKTtcbiAgICAgICAgc29ydGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gcm9vdE5vZGUuYWRkUm9vdChub2RlKSk7XG4gICAgICAgIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbiAgICAgIH0pLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICB9XG5cbiAgb3Blbk9uRmlyc3RVcmwobm9kZTogTmF2aWdhdG9yTm9kZSkge1xuICAgIGlmICh0aGlzLmZpcnN0VXJsICYmICEhbm9kZS5wYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuaXNBY3RpdmUobm9kZS5wYXRoLCBub2RlLnJvdXRlckxpbmtFeGFjdCkgfHwgbm9kZS5vcGVuT25TdGFydCh0aGlzLnJvdXRlci51cmwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxOYXZpZ2F0b3JOb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXNcbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZWZyZXNoVHJpZ2dlci5uZXh0KDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB0byB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0gbmF2IFRoZSBub2RlIHRvIGFkZC5cbiAgICovXG4gIGFkZChpdGVtOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBuYXZpZ2F0b3IuXG4gICAqIEBwYXJhbSBuYXYgVGhlIG5vZGUgcm8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW06IE5hdmlnYXRvck5vZGUpIHtcbiAgICB0aGlzLnN0YXRlLmRlbGV0ZShpdGVtKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG59XG4iXX0=