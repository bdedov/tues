import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to add ActionBarItems using the multi provider extension concept.
 *
 * @example
 * ```typescript
 * providers: [
 *   {
 *     provide: HOOK_ACTION_BAR,
 *     useValue: [{ template: SomeComponent, priority: 10, placement: 'left' } as ActionBarItem],
 *     multi: true
 *   }
 * ]
 * ```
 *
 */
export var HOOK_ACTION_BAR = new InjectionToken('ActionBarFactory');
/**
 * A service which defines action-bar items via the multi provider concept.
 *
 * @example
 * ```typescript
 * // preferred way, multi provider concept:
 * providers: [
 *   {
 *     provide: HOOK_ACTION_BAR,
 *     useValue: [{ template: SomeComponent, priority: 10, placement: 'left' } as ActionBarItem],
 *     multi: true
 *   }
 * ]
 *
 * // use services:
 * this.actionBarService.add({ template: SomeComponent, priority: 10, placement: 'left' });
 * ```
 */
var ActionBarService = /** @class */ (function (_super) {
    tslib_1.__extends(ActionBarService, _super);
    /**
     * @ignore
     */
    function ActionBarService(injector, router) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        _this.refreshTrigger = new Subject();
        _this.state$ = new BehaviorSubject(new Set());
        _this.items$ = fromTrigger(router, _this.refreshTrigger, [
            function () { return _this.injector.get(HOOK_ACTION_BAR, []); },
            stateToFactory(_this.state$)
        ]).pipe(map(function (items) { return sortByPriority(items); }), shareReplay(1));
        return _this;
    }
    Object.defineProperty(ActionBarService.prototype, "state", {
        /**
         * Returns the current state.
         * @readonly
         * @returns The current set of actions.
         */
        get: function () {
            return this.state$.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Refreshes the current store.
     */
    ActionBarService.prototype.refresh = function () {
        this.refreshTrigger.next();
    };
    /**
     * Adds a new item to the action bar in the header and emits a state change.
     * @param item The item to add.
     */
    ActionBarService.prototype.add = function (item) {
        this.state.add(item);
        this.emitNewState();
    };
    /**
     * Removes an action bar item from the header and emits a state change.
     * @param item The item to remove.
     */
    ActionBarService.prototype.remove = function (item) {
        this.state.delete(item);
        this.emitNewState();
    };
    ActionBarService.ctorParameters = function () { return [
        { type: Injector },
        { type: Router }
    ]; };
    ActionBarService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function ActionBarService_Factory() { return new ActionBarService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: ActionBarService, providedIn: "root" });
    ActionBarService = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        })
    ], ActionBarService);
    return ActionBarService;
}(StateService));
export { ActionBarService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9uLWJhci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGM4eS9uZ3gtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImNvcmUvYWN0aW9uLWJhci9hY3Rpb24tYmFyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBRUwsV0FBVyxFQUNYLGNBQWMsRUFDZCxjQUFjLEVBQ2YsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7OztBQUdoRTs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sQ0FBQyxJQUFNLGVBQWUsR0FBRyxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBRXRFOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUlIO0lBQXNDLDRDQUFZO0lBS2hEOztPQUVHO0lBQ0gsMEJBQW9CLFFBQWtCLEVBQUUsTUFBYztRQUF0RCxZQUNFLGlCQUFPLFNBUVI7UUFUbUIsY0FBUSxHQUFSLFFBQVEsQ0FBVTtRQU43QixvQkFBYyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFDOUIsWUFBTSxHQUFHLElBQUksZUFBZSxDQUFxQixJQUFJLEdBQUcsRUFBaUIsQ0FBQyxDQUFDO1FBT25GLEtBQUksQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JELGNBQU0sT0FBQSxLQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLEVBQXRDLENBQXNDO1lBQzVDLGNBQWMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDO1NBQzVCLENBQUMsQ0FBQyxJQUFJLENBQ0wsR0FBRyxDQUFDLFVBQUMsS0FBc0IsSUFBSyxPQUFBLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBckIsQ0FBcUIsQ0FBQyxFQUN0RCxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2YsQ0FBQzs7SUFDSixDQUFDO0lBT0Qsc0JBQUksbUNBQUs7UUFMVDs7OztXQUlHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQzNCLENBQUM7OztPQUFBO0lBRUQ7O09BRUc7SUFDSCxrQ0FBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsOEJBQUcsR0FBSCxVQUFJLElBQW1CO1FBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsaUNBQU0sR0FBTixVQUFPLElBQW1CO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDOztnQkEzQzZCLFFBQVE7Z0JBQVUsTUFBTTs7O0lBUjNDLGdCQUFnQjtRQUg1QixVQUFVLENBQUM7WUFDVixVQUFVLEVBQUUsTUFBTTtTQUNuQixDQUFDO09BQ1csZ0JBQWdCLENBb0Q1QjsyQkF2R0Q7Q0F1R0MsQUFwREQsQ0FBc0MsWUFBWSxHQW9EakQ7U0FwRFksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uUG9pbnQsXG4gIGZyb21UcmlnZ2VyLFxuICBzb3J0QnlQcmlvcml0eSxcbiAgc3RhdGVUb0ZhY3Rvcnlcbn0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBBY3Rpb25CYXJJdGVtIH0gZnJvbSAnLi9hY3Rpb24tYmFyLm1vZGVsJztcblxuLyoqXG4gKiBBIGhvb2sgdG8gYWRkIEFjdGlvbkJhckl0ZW1zIHVzaW5nIHRoZSBtdWx0aSBwcm92aWRlciBleHRlbnNpb24gY29uY2VwdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogcHJvdmlkZXJzOiBbXG4gKiAgIHtcbiAqICAgICBwcm92aWRlOiBIT09LX0FDVElPTl9CQVIsXG4gKiAgICAgdXNlVmFsdWU6IFt7IHRlbXBsYXRlOiBTb21lQ29tcG9uZW50LCBwcmlvcml0eTogMTAsIHBsYWNlbWVudDogJ2xlZnQnIH0gYXMgQWN0aW9uQmFySXRlbV0sXG4gKiAgICAgbXVsdGk6IHRydWVcbiAqICAgfVxuICogXVxuICogYGBgXG4gKlxuICovXG5leHBvcnQgY29uc3QgSE9PS19BQ1RJT05fQkFSID0gbmV3IEluamVjdGlvblRva2VuKCdBY3Rpb25CYXJGYWN0b3J5Jyk7XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgYWN0aW9uLWJhciBpdGVtcyB2aWEgdGhlIG11bHRpIHByb3ZpZGVyIGNvbmNlcHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHByZWZlcnJlZCB3YXksIG11bHRpIHByb3ZpZGVyIGNvbmNlcHQ6XG4gKiBwcm92aWRlcnM6IFtcbiAqICAge1xuICogICAgIHByb3ZpZGU6IEhPT0tfQUNUSU9OX0JBUixcbiAqICAgICB1c2VWYWx1ZTogW3sgdGVtcGxhdGU6IFNvbWVDb21wb25lbnQsIHByaW9yaXR5OiAxMCwgcGxhY2VtZW50OiAnbGVmdCcgfSBhcyBBY3Rpb25CYXJJdGVtXSxcbiAqICAgICBtdWx0aTogdHJ1ZVxuICogICB9XG4gKiBdXG4gKlxuICogLy8gdXNlIHNlcnZpY2VzOlxuICogdGhpcy5hY3Rpb25CYXJTZXJ2aWNlLmFkZCh7IHRlbXBsYXRlOiBTb21lQ29tcG9uZW50LCBwcmlvcml0eTogMTAsIHBsYWNlbWVudDogJ2xlZnQnIH0pO1xuICogYGBgXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEFjdGlvbkJhclNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxBY3Rpb25CYXJJdGVtPiB7XG4gIGl0ZW1zJDogT2JzZXJ2YWJsZTxBY3Rpb25CYXJJdGVtW10+O1xuICByZWFkb25seSByZWZyZXNoVHJpZ2dlciA9IG5ldyBTdWJqZWN0KCk7XG4gIHByb3RlY3RlZCBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxBY3Rpb25CYXJJdGVtPj4obmV3IFNldDxBY3Rpb25CYXJJdGVtPigpKTtcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsIHJvdXRlcjogUm91dGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZW1zJCA9IGZyb21UcmlnZ2VyKHJvdXRlciwgdGhpcy5yZWZyZXNoVHJpZ2dlciwgW1xuICAgICAgKCkgPT4gdGhpcy5pbmplY3Rvci5nZXQoSE9PS19BQ1RJT05fQkFSLCBbXSksXG4gICAgICBzdGF0ZVRvRmFjdG9yeSh0aGlzLnN0YXRlJClcbiAgICBdKS5waXBlKFxuICAgICAgbWFwKChpdGVtczogQWN0aW9uQmFySXRlbVtdKSA9PiBzb3J0QnlQcmlvcml0eShpdGVtcykpLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpOiBTZXQ8QWN0aW9uQmFySXRlbT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIGN1cnJlbnQgc3RvcmUuXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVmcmVzaFRyaWdnZXIubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSB0byB0aGUgYWN0aW9uIGJhciBpbiB0aGUgaGVhZGVyIGFuZCBlbWl0cyBhIHN0YXRlIGNoYW5nZS5cbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgYWRkKGl0ZW06IEFjdGlvbkJhckl0ZW0pIHtcbiAgICB0aGlzLnN0YXRlLmFkZChpdGVtKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYWN0aW9uIGJhciBpdGVtIGZyb20gdGhlIGhlYWRlciBhbmQgZW1pdHMgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtOiBBY3Rpb25CYXJJdGVtKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxufVxuIl19