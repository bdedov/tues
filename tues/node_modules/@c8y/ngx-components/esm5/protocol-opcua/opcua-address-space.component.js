import * as tslib_1 from "tslib";
import { Component, Output, EventEmitter } from '@angular/core';
import { AddressSpaceService, AddressSpaceNode } from './address-space.service';
import { gettext } from '@c8y/ngx-components';
import { OpcuaService } from './opcuaService';
var OpcuaAddressSpaceComponent = /** @class */ (function () {
    function OpcuaAddressSpaceComponent(addressSpaceService, opcuaService) {
        this.addressSpaceService = addressSpaceService;
        this.opcuaService = opcuaService;
        this.selectednode = false;
        this.loading = false;
        this.searchInProgress = false;
        this.focusStatus = new EventEmitter();
        this.moId = '';
    }
    OpcuaAddressSpaceComponent.prototype.ngOnInit = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.filterLabel = gettext('Filterâ€¦');
                this.moId = this.opcuaService.getMoId();
                return [2 /*return*/];
            });
        });
    };
    OpcuaAddressSpaceComponent.prototype.ngOnDestroy = function () {
        // The BehaviourSubject will store the last array of ancestorNodes from the previous search
        // this would cause the component while subscribing in the init-phase to the subject to travers
        // to the last searched node again. From user perspective it does not make sense, because the user
        // left the Address space (tab) and should loose the context and just request a new search or
        // browse the tree manually.
        this.addressSpaceService.resetTreeToRootNode();
    };
    OpcuaAddressSpaceComponent.prototype.searchNodes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.searchInProgress = true;
                        this.clearNodeListAndCheckSearchString();
                        if (!this.isSearch) return [3 /*break*/, 2];
                        this.currentNode = undefined;
                        _a = this;
                        return [4 /*yield*/, this.addressSpaceService.getSearchedNodes(this.searchKey, this.moId)];
                    case 1:
                        _a.nodeList = _b.sent();
                        this.searchInProgress = false;
                        this.nodeList.resultLabel = gettext('Results found');
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    OpcuaAddressSpaceComponent.prototype.clearNodeListAndCheckSearchString = function () {
        this.isSearch = this.searchKey !== undefined && this.searchKey !== '' ? true : false;
        if (!this.isSearch) {
            this.searchInProgress = false;
        }
    };
    OpcuaAddressSpaceComponent.prototype.clearSearch = function () {
        this.isSearch = false;
        this.searchKey = '';
        this.currentNode = undefined;
    };
    OpcuaAddressSpaceComponent.prototype.getIcon = function (nodeClassName) {
        return this.addressSpaceService.getIcon(nodeClassName);
    };
    OpcuaAddressSpaceComponent.prototype.selectNode = function (node) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var res, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(node && node.nodeId && node.nodeId.length > 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.addressSpaceService.getNodeById(this.moId, node.nodeId)];
                    case 1:
                        res = _b.sent();
                        _a = this.toggleCurrentNode;
                        return [4 /*yield*/, res.json()];
                    case 2:
                        _a.apply(this, [(_b.sent())]);
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    OpcuaAddressSpaceComponent.prototype.toggleCurrentNode = function (node) {
        this.currentNode = this.isNodeSet(node) ? undefined : node;
    };
    OpcuaAddressSpaceComponent.prototype.backHandler = function (node) {
        this.isSearch = false;
        this.focusStatus.emit(node);
        this.toggleCurrentNode(node);
    };
    OpcuaAddressSpaceComponent.prototype.isNodeSet = function (node) {
        if (this.currentNode !== undefined && this.currentNode.nodeId === node.nodeId) {
            return true;
        }
        return false;
    };
    OpcuaAddressSpaceComponent.ctorParameters = function () { return [
        { type: AddressSpaceService },
        { type: OpcuaService }
    ]; };
    tslib_1.__decorate([
        Output()
    ], OpcuaAddressSpaceComponent.prototype, "focusStatus", void 0);
    OpcuaAddressSpaceComponent = tslib_1.__decorate([
        Component({
            selector: 'opcua-address-space',
            template: "<div class=\"row split-scroll\">\n  <div class=\"col-md-5 col-xs-12 scroll-column no-gutter-r\">\n    <div class=\"card bg-gray-lighter split-scroll flex-scroll\">\n      <div class=\"card-block separator-bottom\">\n        <div class=\"input-group input-group-search\" style=\"margin: -4px 0;\">\n          <input\n            class=\"form-control\"\n            type=\"search\"\n            placeholder=\"{{ filterLabel | translate }}\"\n            (keydown.enter)=\"searchNodes()\"\n            [(ngModel)]=\"searchKey\"\n          />\n          <span class=\"input-group-btn\">\n            <button *ngIf=\"!isSearch\" type=\"submit\" class=\"btn btn-clean\" (click)=\"searchNodes()\">\n              <i c8yIcon=\"search\"></i>\n            </button>\n            <button *ngIf=\"isSearch\" class=\"btn btn-clean\" (click)=\"clearSearch()\">\n              <i c8yIcon=\"times\"></i>\n            </button>\n          </span>\n        </div>\n        <div *ngIf=\"isSearch && !loading\" class=\"p-t-16\">\n          <p *ngIf=\"!searchInProgress\">\n            <em>{{ nodeList.resultLabel | translate }}</em\n            >&nbsp;\n            <span class=\"badge badge-info\">{{ nodeList?.length }}</span>\n          </p>\n        </div>\n      </div>\n\n      <div style=\"padding: 8px;\" *ngIf=\"(isSearch && loading) || searchInProgress\">\n        <div class=\"spinner\" style=\"position: relative\">\n          <div class=\"rect1\"></div>\n          <div class=\"rect2\"></div>\n          <div class=\"rect3\"></div>\n          <div class=\"rect4\"></div>\n          <div class=\"rect5\"></div>\n        </div>\n      </div>\n\n      <div class=\"flex-content-scroll\" *ngIf=\"isSearch && !loading && !searchInProgress\">\n        <div\n          class=\"list-group list-group-links\"\n          *ngIf=\"isSearch && !loading\"\n          style=\"box-shadow: none;\"\n        >\n          <button\n            *ngFor=\"let nodeItem of nodeList\"\n            (click)=\"selectNode(nodeItem)\"\n            [ngClass]=\"{ 'list-group-item flex-row': true }\"\n          >\n            <div class=\"list-group-icon m-r-4\">\n              <i class=\"right-m-xs\" [c8yIcon]=\"getIcon(nodeItem.nodeClassName)\"></i>\n            </div>\n            <div class=\"list-item-body text-truncate\">\n              <span tile=\"nodeId\">{{ nodeItem.nodeId }}</span> {{ nodeItem.displayName }}\n            </div>\n          </button>\n        </div>\n      </div>\n      <div class=\"flex-content-scroll\" *ngIf=\"!isSearch\">\n        <opcua-address-space-tree\n          (selectedNode)=\"toggleCurrentNode($event)\"\n          [focusEmitter]=\"focusStatus\"\n        ></opcua-address-space-tree>\n      </div>\n    </div>\n  </div>\n  <opcua-address-space-detail\n    [node]=\"currentNode\"\n    class=\"col-md-7 col-xs-12 scroll-column no-gutter-l\"\n    style=\"pointer-events: none;\"\n    (toggleAttrDetail)=\"backHandler($event)\"\n  ></opcua-address-space-detail>\n</div>\n"
        })
    ], OpcuaAddressSpaceComponent);
    return OpcuaAddressSpaceComponent;
}());
export { OpcuaAddressSpaceComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BjdWEtYWRkcmVzcy1zcGFjZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzL3Byb3RvY29sLW9wY3VhLyIsInNvdXJjZXMiOlsib3BjdWEtYWRkcmVzcy1zcGFjZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsTUFBTSxFQUFFLFlBQVksRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNuRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNoRixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFOUMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBTzlDO0lBYUUsb0NBQ1UsbUJBQXdDLEVBQ3hDLFlBQTBCO1FBRDFCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMsaUJBQVksR0FBWixZQUFZLENBQWM7UUFicEMsaUJBQVksR0FBWSxLQUFLLENBQUM7UUFHOUIsWUFBTyxHQUFZLEtBQUssQ0FBQztRQUN6QixxQkFBZ0IsR0FBWSxLQUFLLENBQUM7UUFLeEIsZ0JBQVcsR0FBbUMsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFDckYsU0FBSSxHQUFXLEVBQUUsQ0FBQztJQUl2QixDQUFDO0lBRUUsNkNBQVEsR0FBZDs7O2dCQUNFLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN0QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7Ozs7S0FDekM7SUFFRCxnREFBVyxHQUFYO1FBQ0UsMkZBQTJGO1FBQzNGLCtGQUErRjtRQUMvRixrR0FBa0c7UUFDbEcsNkZBQTZGO1FBQzdGLDRCQUE0QjtRQUM1QixJQUFJLENBQUMsbUJBQW1CLENBQUMsbUJBQW1CLEVBQUUsQ0FB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QUFFO21FQUFvRjtJQVhsRiwwQkFBMEI7UUFKdEMsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLHFCQUFxQjtZQUMvQiw0NkZBQW1EO1NBQ3BELENBQUM7T0FDVywwQkFBMEIsQ0FtRnRDO0lBQUQsaUNBQUM7Q0FBQSxBQW5GRCxJQW1GQztTQW5GWSwwQkFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWRkcmVzc1NwYWNlU2VydmljZSwgQWRkcmVzc1NwYWNlTm9kZSB9IGZyb20gJy4vYWRkcmVzcy1zcGFjZS5zZXJ2aWNlJztcbmltcG9ydCB7IGdldHRleHQgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzJztcbmltcG9ydCB7IER5bmFtaWNEYXRhU291cmNlIH0gZnJvbSAnLi9keW5hbWljLWRhdGEtc291cmNlJztcbmltcG9ydCB7IE9wY3VhU2VydmljZSB9IGZyb20gJy4vb3BjdWFTZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdvcGN1YS1hZGRyZXNzLXNwYWNlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL29wY3VhLWFkZHJlc3Mtc3BhY2UuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIE9wY3VhQWRkcmVzc1NwYWNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBjdXJyZW50Tm9kZTogQWRkcmVzc1NwYWNlTm9kZTtcbiAgc2VsZWN0ZWRub2RlOiBib29sZWFuID0gZmFsc2U7XG4gIHNlYXJjaEtleTogc3RyaW5nO1xuICBpc1NlYXJjaDogYm9vbGVhbjtcbiAgbG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBzZWFyY2hJblByb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG4gIGZpbHRlckxhYmVsOiBzdHJpbmc7XG4gIGRhdGFTb3VyY2U6IER5bmFtaWNEYXRhU291cmNlO1xuICBub2RlTGlzdDtcblxuICBAT3V0cHV0KCkgZm9jdXNTdGF0dXM6IEV2ZW50RW1pdHRlcjxBZGRyZXNzU3BhY2VOb2RlPiA9IG5ldyBFdmVudEVtaXR0ZXI8QWRkcmVzc1NwYWNlTm9kZT4oKTtcbiAgcHJpdmF0ZSBtb0lkOiBzdHJpbmcgPSAnJztcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhZGRyZXNzU3BhY2VTZXJ2aWNlOiBBZGRyZXNzU3BhY2VTZXJ2aWNlLFxuICAgIHByaXZhdGUgb3BjdWFTZXJ2aWNlOiBPcGN1YVNlcnZpY2VcbiAgKSB7fVxuXG4gIGFzeW5jIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZmlsdGVyTGFiZWwgPSBnZXR0ZXh0KCdGaWx0ZXLigKYnKTtcbiAgICB0aGlzLm1vSWQgPSB0aGlzLm9wY3VhU2VydmljZS5nZXRNb0lkKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvLyBUaGUgQmVoYXZpb3VyU3ViamVjdCB3aWxsIHN0b3JlIHRoZSBsYXN0IGFycmF5IG9mIGFuY2VzdG9yTm9kZXMgZnJvbSB0aGUgcHJldmlvdXMgc2VhcmNoXG4gICAgLy8gdGhpcyB3b3VsZCBjYXVzZSB0aGUgY29tcG9uZW50IHdoaWxlIHN1YnNjcmliaW5nIGluIHRoZSBpbml0LXBoYXNlIHRvIHRoZSBzdWJqZWN0IHRvIHRyYXZlcnNcbiAgICAvLyB0byB0aGUgbGFzdCBzZWFyY2hlZCBub2RlIGFnYWluLiBGcm9tIHVzZXIgcGVyc3BlY3RpdmUgaXQgZG9lcyBub3QgbWFrZSBzZW5zZSwgYmVjYXVzZSB0aGUgdXNlclxuICAgIC8vIGxlZnQgdGhlIEFkZHJlc3Mgc3BhY2UgKHRhYikgYW5kIHNob3VsZCBsb29zZSB0aGUgY29udGV4dCBhbmQganVzdCByZXF1ZXN0IGEgbmV3IHNlYXJjaCBvclxuICAgIC8vIGJyb3dzZSB0aGUgdHJlZSBtYW51YWxseS5cbiAgICB0aGlzLmFkZHJlc3NTcGFjZVNlcnZpY2UucmVzZXRUcmVlVG9Sb290Tm9kZSgpO1xuICB9XG5cbiAgYXN5bmMgc2VhcmNoTm9kZXMoKSB7XG4gICAgdGhpcy5zZWFyY2hJblByb2dyZXNzID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyTm9kZUxpc3RBbmRDaGVja1NlYXJjaFN0cmluZygpO1xuICAgIGlmICh0aGlzLmlzU2VhcmNoKSB7XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5ub2RlTGlzdCA9IGF3YWl0IHRoaXMuYWRkcmVzc1NwYWNlU2VydmljZS5nZXRTZWFyY2hlZE5vZGVzKHRoaXMuc2VhcmNoS2V5LCB0aGlzLm1vSWQpO1xuICAgICAgdGhpcy5zZWFyY2hJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICB0aGlzLm5vZGVMaXN0LnJlc3VsdExhYmVsID0gZ2V0dGV4dCgnUmVzdWx0cyBmb3VuZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyTm9kZUxpc3RBbmRDaGVja1NlYXJjaFN0cmluZygpIHtcbiAgICB0aGlzLmlzU2VhcmNoID0gdGhpcy5zZWFyY2hLZXkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNlYXJjaEtleSAhPT0gJycgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKCF0aGlzLmlzU2VhcmNoKSB7XG4gICAgICB0aGlzLnNlYXJjaEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjbGVhclNlYXJjaCgpIHtcbiAgICB0aGlzLmlzU2VhcmNoID0gZmFsc2U7XG4gICAgdGhpcy5zZWFyY2hLZXkgPSAnJztcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0SWNvbihub2RlQ2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzU3BhY2VTZXJ2aWNlLmdldEljb24obm9kZUNsYXNzTmFtZSk7XG4gIH1cblxuICBhc3luYyBzZWxlY3ROb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVJZCAmJiBub2RlLm5vZGVJZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmFkZHJlc3NTcGFjZVNlcnZpY2UuZ2V0Tm9kZUJ5SWQodGhpcy5tb0lkLCBub2RlLm5vZGVJZCk7XG4gICAgICB0aGlzLnRvZ2dsZUN1cnJlbnROb2RlKChhd2FpdCByZXMuanNvbigpKSBhcyBBZGRyZXNzU3BhY2VOb2RlKTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVDdXJyZW50Tm9kZShub2RlOiBBZGRyZXNzU3BhY2VOb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuaXNOb2RlU2V0KG5vZGUpID8gdW5kZWZpbmVkIDogbm9kZTtcbiAgfVxuXG4gIGJhY2tIYW5kbGVyKG5vZGUpIHtcbiAgICB0aGlzLmlzU2VhcmNoID0gZmFsc2U7XG4gICAgdGhpcy5mb2N1c1N0YXR1cy5lbWl0KG5vZGUpO1xuICAgIHRoaXMudG9nZ2xlQ3VycmVudE5vZGUobm9kZSk7XG4gIH1cblxuICBpc05vZGVTZXQobm9kZTogQWRkcmVzc1NwYWNlTm9kZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnROb2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jdXJyZW50Tm9kZS5ub2RlSWQgPT09IG5vZGUubm9kZUlkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=