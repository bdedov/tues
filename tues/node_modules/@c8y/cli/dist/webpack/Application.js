"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("events");
const path = require("path");
const chalk_1 = require("chalk");
const BuildDefaults_1 = require("./BuildDefaults");
const util_1 = require("util");
const options_1 = require("../options");
/**
 * A description for an Cumulocity application.
 */
// tslint:disable-next-line:max-classes-per-file
class Application {
    /**
     * Create a new Cumulocity application.
     */
    constructor(options, entry) {
        this.options = options;
        this.entry = entry;
        this.events = new EventEmitter();
        this.percentage = 0;
        this.msg = '';
        options.globalTitle = options.globalTitle || options_1.options['TXT.GLOBAL_TITLE'];
    }
    get contextPath() {
        return this.options.contextPath;
    }
    get branding() {
        const { brandingEntry } = this.normalizePathOptions(this.options);
        return brandingEntry ? path.resolve(brandingEntry) : BuildDefaults_1.BUILD_DEFAULTS.DEFAULT_BRANDING_PATH;
    }
    createDevelopmentMiddleware(expressApp, extraWebpackEnv) {
        let webpackDevMiddleware;
        let webpackHotMiddleware;
        try {
            webpackDevMiddleware = require('webpack-dev-middleware');
        }
        catch (e) {
            throw new Error('Webpack dev middleware is not installed');
        }
        try {
            webpackHotMiddleware = require('webpack-hot-middleware');
        }
        catch (e) {
            throw new Error('Webpack dev hot middleware is not installed');
        }
        this.createWebpack(extraWebpackEnv);
        const { compiler } = this;
        if (extraWebpackEnv.hmr) {
            expressApp.use(webpackHotMiddleware(compiler));
        }
        return webpackDevMiddleware(compiler, {
            logLevel: 'info',
            stats: extraWebpackEnv.stats || {
                colors: true,
                entrypoints: false,
                chunks: true,
                chunkModules: false,
                chunkOrigins: false,
                chunkGroups: false,
                assets: false,
                modules: false,
                warningsFilter: warning => /@angular.core.fesm5.core.js/.test(warning)
            }
        });
    }
    async build(env) {
        this.createWebpack(env);
        const compilerRun = util_1.promisify(this.compiler.run.bind(this.compiler));
        return await compilerRun();
    }
    createWebpack(extraEnv) {
        let webpack;
        try {
            webpack = require('webpack');
        }
        catch (e) {
            throw new Error('Webpack is not installed');
        }
        const env = Object.assign({ app: this.options, entry: this.entry, branding: this.branding }, extraEnv);
        const normalizedEnv = Object.assign({}, env, { app: this.normalizePathOptions(env.app) });
        // Only load here so that the CLI can be used without the peer dependencies
        const webpackConfig = require('./config/index').configFactory();
        this.compiler = webpack(webpackConfig(normalizedEnv));
        let startTime;
        new webpack.ProgressPlugin((percent, msg, addInfo) => {
            if (percent === 0) {
                startTime = process.hrtime();
            }
            this.percentage = Math.floor(percent * 100);
            addInfo = addInfo ? `- ${addInfo}` : '';
            this.msg = msg ? ` - ${msg} ${addInfo}` : ` - finished in ${this.elapsedTime(startTime)}`;
            if (this.percentage === 100) {
                this.events.emit('build.done');
            }
            else {
                this.events.emit('build.progress');
            }
        }).apply(this.compiler);
    }
    /**
     * Returns the log msg
     */
    getLogMsg(prefix = '') {
        let status = chalk_1.default.yellow(`${this.percentage} %`);
        let app = chalk_1.default.underline(`${prefix}${this.options.contextPath}/`);
        if (!this.compiler) {
            status = chalk_1.default.yellow('waiting');
        }
        if (this.percentage === 100) {
            app = chalk_1.default.green(app);
            status = chalk_1.default.green.bold('done');
        }
        status = this.compiler ? `${status}${chalk_1.default.dim(this.msg)}` : status;
        return `${app} ${status}`;
    }
    normalizePathOptions(appOptions) {
        const pathOptionKeys = ['tsConfigPath', 'brandingEntry', 'entryModule', 'rootNodeModulesPath'];
        return pathOptionKeys.reduce((result, pathOptionKey) => {
            const pathOptionValue = result[pathOptionKey];
            if (pathOptionValue) {
                return Object.assign({}, result, { [pathOptionKey]: this.resolvePathOptionAtEntryPoint(pathOptionValue) });
            }
            return result;
        }, appOptions);
    }
    resolvePathOptionAtEntryPoint(pathOptionValue) {
        if (path.isAbsolute(pathOptionValue)) {
            return pathOptionValue;
        }
        return path.resolve(this.entry, pathOptionValue).replace(/\\/g, '/');
    }
    /**
     * Prints how much time was used for a build
     * @param start the start time
     */
    elapsedTime(start) {
        const precision = 3;
        const elapsed = process.hrtime(start)[1] / 1000000;
        return process.hrtime(start)[0] + ' s - ' + elapsed.toFixed(precision) + ' ms';
    }
}
exports.Application = Application;
//# sourceMappingURL=Application.js.map