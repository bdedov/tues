"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const dev_server_1 = require("@angular-devkit/build-angular/src/dev-server");
const core_1 = require("@angular-devkit/core");
const node_1 = require("@angular-devkit/core/node");
const build_webpack_1 = require("@angular-devkit/build-webpack");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const url = require("url");
const webpack = require("webpack");
const path = require("path");
const check_port_1 = require("@angular-devkit/build-angular/src/angular-cli-files/utilities/check-port");
const browser_1 = require("@angular-devkit/build-angular/src/browser");
const version_1 = require("@angular-devkit/build-angular/src/utils/version");
const open_1 = require("open");
const devServerBuildOverriddenKeys = [
    'watch',
    'optimization',
    'aot',
    'sourceMap',
    'vendorSourceMap',
    'evalSourceMap',
    'vendorChunk',
    'commonChunk',
    'baseHref',
    'progress',
    'poll',
    'verbose',
    'deployUrl',
];
/*
Modified serveWebpackBrowser function from angular-cli
Origin: https://github.com/angular/angular-cli/blob/8.3.x/packages/angular_devkit/build_angular/src/dev-server/index.ts
Diff:
 - remove adding IndexHtmlWebpackPlugin
 - remove WebpackLoggingCallback and IndexHtmlTransform callbacks
*/
function serveWebpackBrowser(options, context, transforms = {}) {
    // Check Angular version.
    version_1.assertCompatibleAngularVersion(context.workspaceRoot, context.logger);
    const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
    const root = context.workspaceRoot;
    let first = true;
    const host = new node_1.NodeJsSyncHost();
    async function setup() {
        // Get the browser configuration from the target name.
        const rawBrowserOptions = await context.getTargetOptions(browserTarget);
        // Override options we need to override, if defined.
        const overrides = Object.keys(options)
            .filter(key => options[key] !== undefined && devServerBuildOverriddenKeys.includes(key))
            .reduce((previous, key) => (Object.assign({}, previous, { [key]: options[key] })), {});
        // In dev server we should not have budgets because of extra libs such as socks-js
        overrides.budgets = undefined;
        const browserName = await context.getBuilderNameForTarget(browserTarget);
        const browserOptions = await context.validateOptions(Object.assign({}, rawBrowserOptions, overrides), browserName);
        const webpackConfigResult = await browser_1.buildBrowserWebpackConfigFromContext(browserOptions, context, host);
        // No differential loading for dev-server, hence there is just one config
        let webpackConfig = webpackConfigResult.config[0];
        const port = await check_port_1.checkPort(options.port || 0, options.host || 'localhost', 4200);
        const webpackDevServerConfig = (webpackConfig.devServer = dev_server_1.buildServerConfig(root, options, browserOptions, context.logger));
        if (transforms.webpackConfiguration) {
            webpackConfig = await transforms.webpackConfiguration(webpackConfig);
        }
        return {
            browserOptions,
            webpackConfig,
            webpackDevServerConfig,
            port,
            workspace: webpackConfigResult.workspace,
        };
    }
    return rxjs_1.from(setup()).pipe(operators_1.switchMap(({ browserOptions, webpackConfig, webpackDevServerConfig, port, workspace }) => {
        options.port = port;
        // Resolve public host and client address.
        let clientAddress = url.parse(`${options.ssl ? 'https' : 'http'}://0.0.0.0:0`);
        if (options.publicHost) {
            let publicHost = options.publicHost;
            if (!/^\w+:\/\//.test(publicHost)) {
                publicHost = `${options.ssl ? 'https' : 'http'}://${publicHost}`;
            }
            clientAddress = url.parse(publicHost);
            options.publicHost = clientAddress.host;
        }
        // Add live reload config.
        if (options.liveReload) {
            _addLiveReload(options, browserOptions, webpackConfig, clientAddress, context.logger);
        }
        else if (options.hmr) {
            context.logger.warn('Live reload is disabled. HMR option ignored.');
        }
        webpackConfig.plugins = [...(webpackConfig.plugins || [])];
        if (!options.watch) {
            // There's no option to turn off file watching in webpack-dev-server, but
            // we can override the file watcher instead.
            webpackConfig.plugins.push({
                // tslint:disable-next-line:no-any
                apply: (compiler) => {
                    compiler.hooks.afterEnvironment.tap('angular-cli', () => {
                        // tslint:disable-next-line:no-empty
                        compiler.watchFileSystem = { watch: () => { } };
                    });
                },
            });
        }
        return build_webpack_1.runWebpackDevServer(webpackConfig, context).pipe(operators_1.map(buildEvent => {
            // Resolve serve address.
            const serverAddress = url.format({
                protocol: options.ssl ? 'https' : 'http',
                hostname: options.host === '0.0.0.0' ? 'localhost' : options.host,
                pathname: webpackDevServerConfig.publicPath,
                port: buildEvent.port,
            });
            if (first) {
                first = false;
                context.logger.info(core_1.tags.oneLine `
              **
              Angular Live Development Server is listening on ${options.host}:${buildEvent.port},
              open your browser on ${serverAddress}
              **
            `);
                if (options.open) {
                    open_1.default(serverAddress);
                }
            }
            return Object.assign({}, buildEvent, { baseUrl: serverAddress });
        }));
    }));
}
exports.serveWebpackBrowser = serveWebpackBrowser;
/**
 * Private method to enhance a webpack config with live reload configuration.
 * @private
 */
function _addLiveReload(options, browserOptions, webpackConfig, clientAddress, logger) {
    if (webpackConfig.plugins === undefined) {
        webpackConfig.plugins = [];
    }
    // Enable the internal node plugins but no individual shims
    // This is needed to allow module specific rules to include node shims
    // Only needed in dev server mode to support live reload capabilities in all package managers
    if (webpackConfig.node === false) {
        webpackConfig.node = {
            global: false,
            process: false,
            __filename: false,
            __dirname: false,
            Buffer: false,
            setImmediate: false,
        };
    }
    // This allows for live reload of page when changes are made to repo.
    // https://webpack.js.org/configuration/dev-server/#devserver-inline
    let webpackDevServerPath;
    try {
        webpackDevServerPath = require.resolve('webpack-dev-server/client');
    }
    catch (_a) {
        throw new Error('The "webpack-dev-server" package could not be found.');
    }
    // If a custom path is provided the webpack dev server client drops the sockjs-node segment.
    // This adds it back so that behavior is consistent when using a custom URL path
    let sockjsPath = '';
    if (clientAddress.pathname) {
        clientAddress.pathname = path.posix.join(clientAddress.pathname, 'sockjs-node');
        sockjsPath = '&sockPath=' + clientAddress.pathname;
        // ensure webpack-dev-server uses the correct path to connect to the reloading socket
        if (webpackConfig.devServer) {
            webpackConfig.devServer.sockPath = clientAddress.pathname;
        }
    }
    const entryPoints = [`${webpackDevServerPath}?${url.format(clientAddress)}${sockjsPath}`];
    if (options.hmr) {
        const webpackHmrLink = 'https://webpack.js.org/guides/hot-module-replacement';
        logger.warn(core_1.tags.oneLine `NOTICE: Hot Module Replacement (HMR) is enabled for the dev server.`);
        const showWarning = options.hmrWarning;
        if (showWarning) {
            logger.info(core_1.tags.stripIndents `
          The project will still live reload when HMR is enabled,
          but to take advantage of HMR additional application code is required'
          (not included in an Angular CLI project by default).'
          See ${webpackHmrLink}
          for information on working with HMR for Webpack.`);
            logger.warn(core_1.tags.oneLine `To disable this warning use "hmrWarning: false" under "serve"
           options in "angular.json".`);
        }
        entryPoints.push('webpack/hot/dev-server');
        webpackConfig.plugins.push(new webpack.HotModuleReplacementPlugin());
        if (browserOptions.extractCss) {
            logger.warn(core_1.tags.oneLine `NOTICE: (HMR) does not allow for CSS hot reload
                when used together with '--extract-css'.`);
        }
    }
    if (typeof webpackConfig.entry !== 'object' || Array.isArray(webpackConfig.entry)) {
        webpackConfig.entry = {};
    }
    if (!Array.isArray(webpackConfig.entry.main)) {
        webpackConfig.entry.main = [];
    }
    webpackConfig.entry.main.unshift(...entryPoints);
}
//# sourceMappingURL=serverWebpackBrowser.js.map