/// <reference types="node" />
import { IFetchClient, Service, IResult, IObservableOptions } from '../core';
import { IApplication } from './IApplication';
import { IApplicationBinary } from './IApplicationBinary';
import { Stream } from 'stream';
export declare class ApplicationBinaryService extends Service<IApplicationBinary> {
    protected baseUrl: any;
    protected listUrl: string;
    protected propertyName: string;
    constructor(client: IFetchClient, applicationOrId: string | number | IApplication);
    upload(binary: ArrayBuffer | Stream | Buffer | File | Blob, fileName?: string): Promise<IResult<IApplicationBinary>>;
    list(): Promise<import("../core").IResultList<IApplicationBinary>>;
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = applicationBinaryService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to compose an observable on your own.
     */
    list$(filter?: object, options?: IObservableOptions): import("rxjs").Observable<IApplicationBinary[]>;
    delete(binaryOrId: string | number | IApplicationBinary): Promise<IResult<null>>;
    listPlugins(): Promise<{
        res: import("../core").IFetchResponse;
        data: any;
    }>;
    addPlugin(pluginName: string, pluginFile: Stream | Buffer | ArrayBuffer): Promise<{
        res: import("../core").IFetchResponse;
        data: any;
    }>;
    removePlugin(pluginName: string): Promise<{
        res: import("../core").IFetchResponse;
        data: any;
    }>;
    updateFiles(files: Array<{
        path: string;
        contents: Stream | Buffer | ArrayBuffer;
    }>): Promise<{
        res: import("../core").IFetchResponse;
        data: any;
    }>;
}
