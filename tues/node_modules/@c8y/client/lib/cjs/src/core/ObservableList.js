"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
/**
 * Creates an observable list (or detail) from a promise-callback.
 *
 * **Deprecated** This class will be removed soon in favor of decoupling
 * this library from rxjs. Use [[Realtime]] for realtime connection and
 * rxjs `defer()` or `from()` to composite an observable on your own.
 */
var ObservableList = /** @class */ (function () {
    /**
     * Creates a observable list with optional paging and realtime configuration.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {any} realtime$ Observable realtime object (optional)
     * @param {IObservableOptions} options The observable configuration
     */
    function ObservableList(request, realtime$, options, realtimeFilter) {
        if (options === void 0) { options = {}; }
        if (realtimeFilter === void 0) { realtimeFilter = {}; }
        this.realtimeFilter = realtimeFilter;
        /**
         * The inner source for the list observable
         */
        this.source = new rxjs_1.Observable();
        this.seed = { mapping: {}, list: [] };
        this.pagingDriver = new rxjs_1.Subject();
        this.specialRealtimeFilter = {
            source: function (o, val) { return o.source.id === val; },
            fragmentType: function (o, val) { return !!o[val]; },
            // the following are not supported or not valid filters
            orderBy: function (o, val) { return true; },
            query: function (o, val) { return true; },
            q: function (o, val) { return true; },
            pageSize: function (o, val) { return true; },
            withTotalPages: function (o, val) { return true; },
            currentPage: function (o, val) { return true; }
        };
        this.defaultObservableOptions = {
            hot: true,
            realtime: false,
            pagingStrategy: PagingStrategy.PROGRESSIVE,
            realtimeAction: RealtimeAction.FULL,
            pagingDelay: 0
        };
        this.options = Object.assign({}, this.defaultObservableOptions, options);
        // cold / paging
        this.source = this.compose(request, this.options.pagingStrategy, this.options.pagingDelay);
        // realtime
        if (this.options.realtime) {
            this.source = this.composeRealtime(realtime$);
        }
        // hot
        if (this.options.hot) {
            this.source = this.composeHot();
        }
    }
    /**
     * Load more data from this service (next page).
     */
    ObservableList.prototype.more = function () {
        if (this.options.pagingStrategy !== PagingStrategy.PROGRESSIVE) {
            throw new Error('Only PagingStrategy.PROGRESSIVE does support load more button.');
        }
        var paging = this.pagingDriver.paging;
        var fetching = !paging || paging.fetching;
        fetching = this.fetchNextPage(fetching, paging);
        return fetching;
    };
    ObservableList.prototype.composeDetail = function () {
        return this.source.pipe(operators_1.map(function (list) { return list[0]; }));
    };
    /**
     * Creates a observable with the given paging strategy.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {PagingStrategy} pagingStrategy The paging strategy to use.
     * @param {number} pagingDelay If all pages are loaded, the paging is delayed by x ms.
     */
    ObservableList.prototype.compose = function (request, pagingStrategy, pagingDelay) {
        if (pagingStrategy === void 0) { pagingStrategy = PagingStrategy.PROGRESSIVE; }
        if (pagingDelay === void 0) { pagingDelay = 0; }
        var firstPage$ = rxjs_1.defer(function () { return rxjs_1.from(request()); });
        return pagingStrategy === PagingStrategy.PROGRESSIVE
            ? this.composeProgressive(firstPage$)
            : this.composeAllOrNone(firstPage$, pagingStrategy, pagingDelay);
    };
    ObservableList.prototype.composeRealtime = function (realtime$, action) {
        var _this = this;
        if (action === void 0) { action = RealtimeAction.FULL; }
        if (!realtime$) {
            // tslint:disable-next-line:max-line-length
            throw new Error('Cannot compose realtime without setting realtime observable in service constructor.');
        }
        realtime$ = realtime$.pipe(operators_1.filter(function (result) { return _this.filterAction(result, action); }), operators_1.filter(function (result) { return _this.filterRealtime(result); }), operators_1.map(this.mapData));
        return this.source.pipe(operators_1.merge(realtime$), operators_1.scan(this.accumulator, this.seed), operators_1.map(function (_a) {
            var list = _a.list;
            return list;
        }));
    };
    ObservableList.prototype.composeHot = function () {
        return this.source.pipe(operators_1.publishReplay(1), operators_1.refCount());
    };
    ObservableList.prototype.fetchNextPage = function (fetching, paging) {
        if (!fetching && !paging.done) {
            var isLast = paging.currentPage >= paging.totalPages;
            this.pagingDriver.next(isLast ? rxjs_1.empty() : paging.next());
            paging.done = isLast;
            fetching = paging.fetching = !isLast;
        }
        return fetching;
    };
    ObservableList.prototype.composeAllOrNone = function (firstPage$, pagingStrategy, pagingDelay) {
        var _this = this;
        return firstPage$.pipe(operators_1.expand(function (_a) {
            var paging = _a.paging;
            return _this.shouldUsePaging(paging, pagingStrategy)
                ? rxjs_1.from(paging.next()).pipe(operators_1.delay(pagingDelay))
                : rxjs_1.empty();
        }), operators_1.map(this.mapData));
    };
    ObservableList.prototype.composeProgressive = function (firstPage$) {
        var _this = this;
        return this.pagingDriver.pipe(operators_1.mergeMap(function (r) { return r; }), operators_1.merge(firstPage$), operators_1.tap(function (_a) {
            var paging = _a.paging;
            if (paging) {
                _this.pagingDriver.paging = paging;
            }
        }), operators_1.map(this.mapData));
    };
    ObservableList.prototype.shouldUsePaging = function (paging, pagingStrategy) {
        if (pagingStrategy === PagingStrategy.ALL && !paging.totalPages) {
            return !!paging.nextPage;
        }
        return (paging && pagingStrategy === PagingStrategy.ALL && paging.currentPage < paging.totalPages);
    };
    ObservableList.prototype.accumulator = function (acc, rtItemOrList) {
        var mapping = acc.mapping, list = acc.list;
        // if deleted, realtime just returns an string-id
        if (typeof rtItemOrList === 'string') {
            var index = list.indexOf(mapping[rtItemOrList]);
            if (index > -1) {
                list.splice(index, 1);
                mapping[rtItemOrList] = undefined;
            }
            return acc;
        }
        var items = Array.isArray(rtItemOrList) ? rtItemOrList : [rtItemOrList];
        items.forEach(function (item, index) {
            if (mapping[item.id]) {
                mapping[item.id] = Object.assign(mapping[item.id], item);
            }
            else {
                mapping[item.id] = item;
                list.push(item);
            }
        });
        return acc;
    };
    ObservableList.prototype.filterAction = function (result, action) {
        return action === RealtimeAction.FULL || action === result.realtimeAction;
    };
    ObservableList.prototype.filterRealtime = function (result) {
        if (this.options.realtimeFilter) {
            return this.options.realtimeFilter(result);
        }
        else if (result.realtimeAction === RealtimeAction.CREATE) {
            var data = result.data;
            var valid = true;
            // tslint:disable-next-line:forin
            for (var key in this.realtimeFilter) {
                var specialFn = this.specialRealtimeFilter[key];
                valid = specialFn
                    ? this.specialRealtimeFilter[key](data, this.realtimeFilter[key])
                    : data[key] === this.realtimeFilter[key];
                if (!valid) {
                    break;
                }
            }
            return valid;
        }
        return true;
    };
    ObservableList.prototype.mapData = function (result) {
        return result.data;
    };
    return ObservableList;
}());
exports.ObservableList = ObservableList;
var RealtimeAction;
(function (RealtimeAction) {
    RealtimeAction["UPDATE"] = "UPDATE";
    RealtimeAction["DELETE"] = "DELETE";
    RealtimeAction["CREATE"] = "CREATE";
    RealtimeAction["FULL"] = "FULL";
})(RealtimeAction = exports.RealtimeAction || (exports.RealtimeAction = {}));
var PagingStrategy;
(function (PagingStrategy) {
    PagingStrategy["ALL"] = "ALL";
    PagingStrategy["PROGRESSIVE"] = "PROGRESSIVE";
    PagingStrategy["NONE"] = "NONE";
})(PagingStrategy = exports.PagingStrategy || (exports.PagingStrategy = {}));
//# sourceMappingURL=ObservableList.js.map