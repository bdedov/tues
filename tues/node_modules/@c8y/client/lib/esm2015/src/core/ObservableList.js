import { Observable, Subject, defer, from, empty } from 'rxjs';
import { filter as filterObs, merge, refCount, map, expand, scan, delay, publishReplay, mergeMap, tap } from 'rxjs/operators';
/**
 * Creates an observable list (or detail) from a promise-callback.
 *
 * **Deprecated** This class will be removed soon in favor of decoupling
 * this library from rxjs. Use [[Realtime]] for realtime connection and
 * rxjs `defer()` or `from()` to composite an observable on your own.
 */
export class ObservableList {
    /**
     * Creates a observable list with optional paging and realtime configuration.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {any} realtime$ Observable realtime object (optional)
     * @param {IObservableOptions} options The observable configuration
     */
    constructor(request, realtime$, options = {}, realtimeFilter = {}) {
        this.realtimeFilter = realtimeFilter;
        /**
         * The inner source for the list observable
         */
        this.source = new Observable();
        this.seed = { mapping: {}, list: [] };
        this.pagingDriver = new Subject();
        this.specialRealtimeFilter = {
            source: (o, val) => o.source.id === val,
            fragmentType: (o, val) => !!o[val],
            // the following are not supported or not valid filters
            orderBy: (o, val) => true,
            query: (o, val) => true,
            q: (o, val) => true,
            pageSize: (o, val) => true,
            withTotalPages: (o, val) => true,
            currentPage: (o, val) => true
        };
        this.defaultObservableOptions = {
            hot: true,
            realtime: false,
            pagingStrategy: PagingStrategy.PROGRESSIVE,
            realtimeAction: RealtimeAction.FULL,
            pagingDelay: 0
        };
        this.options = Object.assign({}, this.defaultObservableOptions, options);
        // cold / paging
        this.source = this.compose(request, this.options.pagingStrategy, this.options.pagingDelay);
        // realtime
        if (this.options.realtime) {
            this.source = this.composeRealtime(realtime$);
        }
        // hot
        if (this.options.hot) {
            this.source = this.composeHot();
        }
    }
    /**
     * Load more data from this service (next page).
     */
    more() {
        if (this.options.pagingStrategy !== PagingStrategy.PROGRESSIVE) {
            throw new Error('Only PagingStrategy.PROGRESSIVE does support load more button.');
        }
        const { paging } = this.pagingDriver;
        let fetching = !paging || paging.fetching;
        fetching = this.fetchNextPage(fetching, paging);
        return fetching;
    }
    composeDetail() {
        return this.source.pipe(map(list => list[0]));
    }
    /**
     * Creates a observable with the given paging strategy.
     *
     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
     * @param {PagingStrategy} pagingStrategy The paging strategy to use.
     * @param {number} pagingDelay If all pages are loaded, the paging is delayed by x ms.
     */
    compose(request, pagingStrategy = PagingStrategy.PROGRESSIVE, pagingDelay = 0) {
        const firstPage$ = defer(() => from(request()));
        return pagingStrategy === PagingStrategy.PROGRESSIVE
            ? this.composeProgressive(firstPage$)
            : this.composeAllOrNone(firstPage$, pagingStrategy, pagingDelay);
    }
    composeRealtime(realtime$, action = RealtimeAction.FULL) {
        if (!realtime$) {
            // tslint:disable-next-line:max-line-length
            throw new Error('Cannot compose realtime without setting realtime observable in service constructor.');
        }
        realtime$ = realtime$.pipe(filterObs(result => this.filterAction(result, action)), filterObs(result => this.filterRealtime(result)), map(this.mapData));
        return this.source.pipe(merge(realtime$), scan(this.accumulator, this.seed), map(({ list }) => list));
    }
    composeHot() {
        return this.source.pipe(publishReplay(1), refCount());
    }
    fetchNextPage(fetching, paging) {
        if (!fetching && !paging.done) {
            const isLast = paging.currentPage >= paging.totalPages;
            this.pagingDriver.next(isLast ? empty() : paging.next());
            paging.done = isLast;
            fetching = paging.fetching = !isLast;
        }
        return fetching;
    }
    composeAllOrNone(firstPage$, pagingStrategy, pagingDelay) {
        return firstPage$.pipe(expand(({ paging }) => this.shouldUsePaging(paging, pagingStrategy)
            ? from(paging.next()).pipe(delay(pagingDelay))
            : empty()), map(this.mapData));
    }
    composeProgressive(firstPage$) {
        return this.pagingDriver.pipe(mergeMap((r) => r), merge(firstPage$), tap(({ paging }) => {
            if (paging) {
                this.pagingDriver.paging = paging;
            }
        }), map(this.mapData));
    }
    shouldUsePaging(paging, pagingStrategy) {
        if (pagingStrategy === PagingStrategy.ALL && !paging.totalPages) {
            return !!paging.nextPage;
        }
        return (paging && pagingStrategy === PagingStrategy.ALL && paging.currentPage < paging.totalPages);
    }
    accumulator(acc, rtItemOrList) {
        const { mapping, list } = acc;
        // if deleted, realtime just returns an string-id
        if (typeof rtItemOrList === 'string') {
            const index = list.indexOf(mapping[rtItemOrList]);
            if (index > -1) {
                list.splice(index, 1);
                mapping[rtItemOrList] = undefined;
            }
            return acc;
        }
        const items = Array.isArray(rtItemOrList) ? rtItemOrList : [rtItemOrList];
        items.forEach((item, index) => {
            if (mapping[item.id]) {
                mapping[item.id] = Object.assign(mapping[item.id], item);
            }
            else {
                mapping[item.id] = item;
                list.push(item);
            }
        });
        return acc;
    }
    filterAction(result, action) {
        return action === RealtimeAction.FULL || action === result.realtimeAction;
    }
    filterRealtime(result) {
        if (this.options.realtimeFilter) {
            return this.options.realtimeFilter(result);
        }
        else if (result.realtimeAction === RealtimeAction.CREATE) {
            const data = result.data;
            let valid = true;
            // tslint:disable-next-line:forin
            for (const key in this.realtimeFilter) {
                const specialFn = this.specialRealtimeFilter[key];
                valid = specialFn
                    ? this.specialRealtimeFilter[key](data, this.realtimeFilter[key])
                    : data[key] === this.realtimeFilter[key];
                if (!valid) {
                    break;
                }
            }
            return valid;
        }
        return true;
    }
    mapData(result) {
        return result.data;
    }
}
export var RealtimeAction;
(function (RealtimeAction) {
    RealtimeAction["UPDATE"] = "UPDATE";
    RealtimeAction["DELETE"] = "DELETE";
    RealtimeAction["CREATE"] = "CREATE";
    RealtimeAction["FULL"] = "FULL";
})(RealtimeAction || (RealtimeAction = {}));
export var PagingStrategy;
(function (PagingStrategy) {
    PagingStrategy["ALL"] = "ALL";
    PagingStrategy["PROGRESSIVE"] = "PROGRESSIVE";
    PagingStrategy["NONE"] = "NONE";
})(PagingStrategy || (PagingStrategy = {}));
//# sourceMappingURL=ObservableList.js.map