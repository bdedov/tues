import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, map, combineLatest, delay, debounceTime } from 'rxjs/operators';
import { OptionsService } from '../common/options.service';
import { StateService } from '../common/state-service.abstract';
import { NavigatorService } from '../navigator/navigator.service';
import * as i0 from "@angular/core";
import * as i1 from "../navigator/navigator.service";
import * as i2 from "../common/options.service";
/**
 * A service which defines header functions.
 */
let HeaderService = class HeaderService extends StateService {
    constructor(navigatorService, options) {
        super();
        this.navigatorService = navigatorService;
        this.options = options;
        this.DELAY_TO_AVOID_FLICKERING_ON_ASYNC_NODES = 1000;
        this.hasItemsInNavigator$ = this.navigatorService.items$.pipe(delay(this.DELAY_TO_AVOID_FLICKERING_ON_ASYNC_NODES), map(({ length }) => !!length), distinctUntilChanged());
        this.state$ = new BehaviorSubject({
            title: undefined,
            nav: {
                open: false
            }
        });
        this.title = undefined;
        this.header$ = this.map((header) => header);
        this.navigatorOpen$ = this.map(({ nav }) => nav.open).pipe(combineLatest(this.hasItemsInNavigator$), map(([open, hasItems]) => open && hasItems));
        const titleReference = document.querySelector('title');
        this.title = {
            elementRef: titleReference,
            originalValue: titleReference && titleReference.innerText
        };
    }
    get state() {
        return this.state$.value;
    }
    get navigatorHiddenOnStartup() {
        return this.options.hideNavigator;
    }
    get largeWidth() {
        return document.documentElement.clientWidth > 1200;
    }
    get shouldToggle() {
        return this.largeWidth && !this.navigatorHiddenOnStartup && !this.state.nav.open;
    }
    /**
     * Toggles the navigator open status.
     */
    toggleNavigator() {
        this.state.nav.open = !this.state.nav.open;
        this.emitNewState();
    }
    /**
     * Force to close the navigator.
     */
    closeNavigator() {
        this.state.nav.open = false;
        this.emitNewState();
    }
    /**
     * Configures navigation options.
     * @param config Object with the properties:
     * - open: Boolean
     */
    configNavigator(config = {}) {
        this.state.nav = Object.assign(this.state.nav, config);
        this.emitNewState();
    }
    /**
     * Change the application title.
     * @param newTitle The new title of the application.
     */
    changeTitle(newTitle, pageTitleUpdate = true) {
        this.state.title = newTitle;
        this.state.pageTitleUpdate = pageTitleUpdate;
        this.emitNewState();
    }
    /**
     * Change the page title.
     * @param newTitle The new title of the page.
     */
    changePageTitle(newTitle) {
        this.title.elementRef.innerText = newTitle
            ? `${newTitle} / ${this.title.originalValue}`
            : `${this.title.originalValue}`;
    }
    /**
     * This methods checks if the navigator toggles on startup
     * or if an item is added to the navigator node.
     * Delay of 300ms is intended for animation purpose.
     */
    verifyIfNavOpen() {
        this.hasItemsInNavigator$
            .pipe(debounceTime(300))
            .subscribe(hasItems => hasItems && this.shouldToggle && this.toggleNavigator());
    }
    shouldShowBreadcrumbs() {
        return this.options.breadcrumbs;
    }
};
HeaderService.ctorParameters = () => [
    { type: NavigatorService },
    { type: OptionsService }
];
HeaderService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function HeaderService_Factory() { return new HeaderService(i0.ɵɵinject(i1.NavigatorService), i0.ɵɵinject(i2.OptionsService)); }, token: HeaderService, providedIn: "root" });
HeaderService = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    })
], HeaderService);
export { HeaderService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhZGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9oZWFkZXIvaGVhZGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGVBQWUsRUFBa0IsTUFBTSxNQUFNLENBQUM7QUFDdkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9GLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDaEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7Ozs7QUFHbEU7O0dBRUc7QUFJSCxJQUFhLGFBQWEsR0FBMUIsTUFBYSxhQUFjLFNBQVEsWUFBWTtJQW9CN0MsWUFBb0IsZ0JBQWtDLEVBQVUsT0FBdUI7UUFDckYsS0FBSyxFQUFFLENBQUM7UUFEVSxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBZ0I7UUFqQjlFLDZDQUF3QyxHQUFHLElBQUksQ0FBQztRQUV6RCx5QkFBb0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDdEQsS0FBSyxDQUFDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQyxFQUNwRCxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQzdCLG9CQUFvQixFQUFFLENBQ3ZCLENBQUM7UUFFRixXQUFNLEdBQTRCLElBQUksZUFBZSxDQUFTO1lBQzVELEtBQUssRUFBRSxTQUFTO1lBQ2hCLEdBQUcsRUFB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Q0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDdkIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUVELHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO0lBQ2xDLENBQUM7Q0FDRixDQUFBOztZQTNGdUMsZ0JBQWdCO1lBQW1CLGNBQWM7OztBQXBCNUUsYUFBYTtJQUh6QixVQUFVLENBQUM7UUFDVixVQUFVLEVBQUUsTUFBTTtLQUNuQixDQUFDO0dBQ1csYUFBYSxDQStHekI7U0EvR1ksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIGNvbWJpbmVMYXRlc3QsIGRlbGF5LCBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPcHRpb25zU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3N0YXRlLXNlcnZpY2UuYWJzdHJhY3QnO1xuaW1wb3J0IHsgTmF2aWdhdG9yU2VydmljZSB9IGZyb20gJy4uL25hdmlnYXRvci9uYXZpZ2F0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBIZWFkZXIgfSBmcm9tICcuL2hlYWRlci5tb2RlbCc7XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgaGVhZGVyIGZ1bmN0aW9ucy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSGVhZGVyU2VydmljZSBleHRlbmRzIFN0YXRlU2VydmljZSB7XG4gIGhlYWRlciQ6IE9ic2VydmFibGU8SGVhZGVyPjtcbiAgbmF2aWdhdG9yT3BlbiQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gIHJlYWRvbmx5IERFTEFZX1RPX0FWT0lEX0ZMSUNLRVJJTkdfT05fQVNZTkNfTk9ERVMgPSAxMDAwO1xuXG4gIGhhc0l0ZW1zSW5OYXZpZ2F0b3IkID0gdGhpcy5uYXZpZ2F0b3JTZXJ2aWNlLml0ZW1zJC5waXBlKFxuICAgIGRlbGF5KHRoaXMuREVMQVlfVE9fQVZPSURfRkxJQ0tFUklOR19PTl9BU1lOQ19OT0RFUyksXG4gICAgbWFwKCh7IGxlbmd0aCB9KSA9PiAhIWxlbmd0aCksXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICApO1xuXG4gIHN0YXRlJDogQmVoYXZpb3JTdWJqZWN0PEhlYWRlcj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhlYWRlcj4oe1xuICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgbmF2OiB7XG4gICAgICBvcGVuOiBmYWxzZVxuICAgIH1cbiAgfSk7XG5cbiAgdGl0bGUgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuYXZpZ2F0b3JTZXJ2aWNlOiBOYXZpZ2F0b3JTZXJ2aWNlLCBwcml2YXRlIG9wdGlvbnM6IE9wdGlvbnNTZXJ2aWNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhlYWRlciQgPSB0aGlzLm1hcCgoaGVhZGVyOiBIZWFkZXIpID0+IGhlYWRlcik7XG4gICAgdGhpcy5uYXZpZ2F0b3JPcGVuJCA9IHRoaXMubWFwKCh7IG5hdiB9KSA9PiBuYXYub3BlbikucGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3QodGhpcy5oYXNJdGVtc0luTmF2aWdhdG9yJCksXG4gICAgICBtYXAoKFtvcGVuLCBoYXNJdGVtc10pID0+IG9wZW4gJiYgaGFzSXRlbXMpXG4gICAgKTtcbiAgICBjb25zdCB0aXRsZVJlZmVyZW5jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJyk7XG4gICAgdGhpcy50aXRsZSA9IHtcbiAgICAgIGVsZW1lbnRSZWY6IHRpdGxlUmVmZXJlbmNlLFxuICAgICAgb3JpZ2luYWxWYWx1ZTogdGl0bGVSZWZlcmVuY2UgJiYgdGl0bGVSZWZlcmVuY2UuaW5uZXJUZXh0XG4gICAgfTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICBnZXQgbmF2aWdhdG9ySGlkZGVuT25TdGFydHVwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaGlkZU5hdmlnYXRvcjtcbiAgfVxuXG4gIGdldCBsYXJnZVdpZHRoKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPiAxMjAwO1xuICB9XG5cbiAgZ2V0IHNob3VsZFRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXJnZVdpZHRoICYmICF0aGlzLm5hdmlnYXRvckhpZGRlbk9uU3RhcnR1cCAmJiAhdGhpcy5zdGF0ZS5uYXYub3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBuYXZpZ2F0b3Igb3BlbiBzdGF0dXMuXG4gICAqL1xuICB0b2dnbGVOYXZpZ2F0b3IoKSB7XG4gICAgdGhpcy5zdGF0ZS5uYXYub3BlbiA9ICF0aGlzLnN0YXRlLm5hdi5vcGVuO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdG8gY2xvc2UgdGhlIG5hdmlnYXRvci5cbiAgICovXG4gIGNsb3NlTmF2aWdhdG9yKCkge1xuICAgIHRoaXMuc3RhdGUubmF2Lm9wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgbmF2aWdhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gY29uZmlnIE9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzOlxuICAgKiAtIG9wZW46IEJvb2xlYW5cbiAgICovXG4gIGNvbmZpZ05hdmlnYXRvcihjb25maWc6IGFueSA9IHt9KSB7XG4gICAgdGhpcy5zdGF0ZS5uYXYgPSBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUubmF2LCBjb25maWcpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBhcHBsaWNhdGlvbiB0aXRsZS5cbiAgICogQHBhcmFtIG5ld1RpdGxlIFRoZSBuZXcgdGl0bGUgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgY2hhbmdlVGl0bGUobmV3VGl0bGU/OiBhbnksIHBhZ2VUaXRsZVVwZGF0ZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICB0aGlzLnN0YXRlLnRpdGxlID0gbmV3VGl0bGU7XG4gICAgdGhpcy5zdGF0ZS5wYWdlVGl0bGVVcGRhdGUgPSBwYWdlVGl0bGVVcGRhdGU7XG5cbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgcGFnZSB0aXRsZS5cbiAgICogQHBhcmFtIG5ld1RpdGxlIFRoZSBuZXcgdGl0bGUgb2YgdGhlIHBhZ2UuXG4gICAqL1xuICBjaGFuZ2VQYWdlVGl0bGUobmV3VGl0bGU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLnRpdGxlLmVsZW1lbnRSZWYuaW5uZXJUZXh0ID0gbmV3VGl0bGVcbiAgICAgID8gYCR7bmV3VGl0bGV9IC8gJHt0aGlzLnRpdGxlLm9yaWdpbmFsVmFsdWV9YFxuICAgICAgOiBgJHt0aGlzLnRpdGxlLm9yaWdpbmFsVmFsdWV9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgY2hlY2tzIGlmIHRoZSBuYXZpZ2F0b3IgdG9nZ2xlcyBvbiBzdGFydHVwXG4gICAqIG9yIGlmIGFuIGl0ZW0gaXMgYWRkZWQgdG8gdGhlIG5hdmlnYXRvciBub2RlLlxuICAgKiBEZWxheSBvZiAzMDBtcyBpcyBpbnRlbmRlZCBmb3IgYW5pbWF0aW9uIHB1cnBvc2UuXG4gICAqL1xuICB2ZXJpZnlJZk5hdk9wZW4oKSB7XG4gICAgdGhpcy5oYXNJdGVtc0luTmF2aWdhdG9yJFxuICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKDMwMCkpXG4gICAgICAuc3Vic2NyaWJlKGhhc0l0ZW1zID0+IGhhc0l0ZW1zICYmIHRoaXMuc2hvdWxkVG9nZ2xlICYmIHRoaXMudG9nZ2xlTmF2aWdhdG9yKCkpO1xuICB9XG5cbiAgc2hvdWxkU2hvd0JyZWFkY3J1bWJzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYnJlYWRjcnVtYnM7XG4gIH1cbn1cbiJdfQ==