var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Service } from '../core';
import FormData from 'form-data';
export class ApplicationBinaryService extends Service {
    constructor(client, applicationOrId) {
        super(client);
        this.listUrl = 'binaries';
        this.propertyName = 'attachments';
        this.baseUrl = `application/applications/${this.getIdString(applicationOrId)}`;
    }
    upload(binary, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.listUrl;
            const method = 'POST';
            const body = new FormData();
            const bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
            let uploadFileName = fileName;
            if (typeof (File) !== 'undefined' && binary instanceof File) {
                uploadFileName = binary.name;
            }
            body.append('file', bufferOrStream, uploadFileName);
            body.append('fileName', uploadFileName);
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    list() {
        const _super = Object.create(null, {
            list: { get: () => super.list }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.list.call(this);
        });
    }
    /**
     * Gets a list as observable.
     *
     * @param {object} filter Object containing filters for querying
     * @param {object} options To configure the observable
     *
     * @returns Data wrapped as Observable.
     *
     * @example
     * ```typescript
     *
     *   const list$ = applicationBinaryService.list$();
     *   list$.subscribe((data) => console.log(data));
     * ```
     *
     * @deprecated This function will be removed soon in favor of decoupling
     * this library from rxjs. Use [[Realtime]] for realtime connection and
     * rxjs `defer()` or `from()` to compose an observable on your own.
     */
    list$(filter = {}, options = {}) {
        return super.list$(filter, options);
    }
    delete(binaryOrId) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.delete.call(this, binaryOrId);
        });
    }
    listPlugins() {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { accept: 'application/json' };
            const url = `${this.listUrl}/plugins`;
            const res = yield this.fetch(url, { headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    addPlugin(pluginName, pluginFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/plugins/${encodeURIComponent(pluginName)}`;
            const method = 'POST';
            const body = new FormData();
            const bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
            body.append('file', bufferOrStream);
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    removePlugin(pluginName) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = 'DELETE';
            const headers = { accept: 'application/json' };
            const url = `${this.listUrl}/plugins/${pluginName}`;
            const res = yield this.fetch(url, { method, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
    updateFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.listUrl}/files`;
            const method = 'POST';
            const body = new FormData();
            files.forEach((file) => {
                const bufferOrStream = file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;
                body.append(file.path, bufferOrStream);
            });
            let bodyHeaders;
            if (typeof body.getHeaders === 'function') {
                bodyHeaders = body.getHeaders();
            }
            const headers = Object.assign({
                accept: 'application/json'
            }, bodyHeaders);
            const res = yield this.fetch(url, { method, body, headers });
            const data = yield res.json();
            return { res, data };
        });
    }
}
//# sourceMappingURL=ApplicationBinaryService.js.map